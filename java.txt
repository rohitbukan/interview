1)	What is Object Oriented Programming?
Ans:- Object-oriented programming (OOP) is a programming based on the concept of "objects", which are data structures that contain data, in the form of fields, often known as attributes and code in the form of procedures, often known as methods.
2)	What are the advantages of Object Oriented Programming?
1.	Ans:- Simplicity: OOPS programming objects model real world objects, so the complexity is reduced and the program structure is clear.
2.	Modularity: Each object forms a separate entity whose internal workings are decoupled from other parts of the system.
3.	Modifiability: It is easy to make minor changes in the data representation or the procedures in an OO program. Changes inside a class do not affect any other part of a program, since the only public interface that the external world has to a class is through the use of methods.
4.	Extensibility: Adding new features or responding to changing operating environments can be solved by introducing a few new objects and modifying some existing ones.
5.	Maintainability: Objects can be maintained separately, making locating and fixing problems easier.
6.	Reusability: Objects can be reused in different programs.


3) what are the advantages of oops over pop?
ans:- 
1)OOPs makes development and maintenance easier where as in Procedure-oriented programming language it is not easy to manage if code grows as project size grows.
2)OOPs provides data hiding whereas in Procedure-oriented programming language a global data can be accessed from anywhere.
3)OOPs provides ability to simulate real-world event much more effectively. We can provide the solution of real word problem if we are using the Object-Oriented Programming language.
 	 


4)What is the difference between class and object?
Ans:- class is just a blueprint. A class defines the available characteristics and behavior of a set of similar objects.
e.g.  Car class defined has so many attributes and behaviour such as start(),stop(),accelerate() etc,
object or instance is basic runtime entity. E.g. Maruti Alto, WaganR, Maruti Swift etc.

3)	give some real life examples of Object.
Ans:- The world can be considered to consist of many objects. Objects will have attributes and behaviors. 
A water-heater is a simple example of an object. It has certain attributes or properties (like color, size, maximum and current temperatures etc.) and there are certain behaviors associated with the water-heater (like switching on the heater, increasing the temperature or heating for a specified time interval, switching off the heater etc.). These are actions that can be performed on the heater. Or in other words they are actions which can modify certain properties of the heater (for instance by switching on the heater the current temperature of the heater will change).
A car is another example of an object. It has a lot of attributes such as fuel capacity, current speed, top speed, number of wheels, type of gearbox etc. There are also a lot of operations which you can perform on this object. For example: you can accelerate the car, apply brakes etc.


5) What do you mean by ADT?
Ans:- ADTs stand for abstract data types. Classes which provide data abstraction are referred to as ADTs.
6) What is Abstraction?
Ans:- Abstraction is the process of extracting the relevant properties of an object while ignoring nonessential details relative to the perspective of the viewer.
	e.g.
•	A doctor sees (abstracts) the person as patient.  The doctor is interested in name, height, weight, age, blood group,  previous or existing diseases etc of a person whereas An employer sees (abstracts) a person as Employee. The employer is interested in name, age,  health, degree of study, work experience  etc of a person.   
•	For a sales tracking system relevant attributes of a salesperson might be: name, number of vehicles sold, value of vehicles sold, list of customers, commission rate, total commissions.
•	A car dealer might view a car from the standpoint of its selling features. Relevant properties include price, color, optional equipment, and length of warranty. On the other hand , mechanic views the car from the standpoint of systems that require maintenance. Here relevant properties include the type of oil, the size of oil filter, and the number and type of spark plug.
7) What is Encapsulation?
Ans:- Encapsulation is the process of separating the aspects of an object into external and internal aspects. The external aspects of an object need to be visible or known , to other objects in the system.  The internal aspects are details that should not affect other parts of the system. Hiding the internal aspects of an object means that they can be changed without affecting external aspects of the system.  
e.g.
a) Encapsulation in a Real World Elevator System
Any useful elevator has a mechanism, such as buttons, that allow a passenger to select his or her destination floor. (we have two objects here   Elevator  and Person ). Pressing a button is a very easy action to perform for the user of the elevator. However, for the elevator faced with many conflicting simultaneous requests from many different people, it can be a complicated matter deciding which floor to go to and fulfill the request of each traveler appropriately. 
e.g  Person A might enter the elevator at floor 3 and request to go to floor 30. However, another person, B, has already pressed the button on floor 1 requesting to be picked up there. If the elevator goes directly to floor 30 with person A (but without B), person A will get there as fast as he or she could ever expect. However, person B has to wait. Perhaps, by merely moving two floors down, the elevator could have taken both people to a higher floor at the same time, saving time and power. Instead, the elevator has to go all the way up to floor 30 and then back down to pick up B. With many people constantly requesting elevators and destination floors, the matter gets much more complex as far as implementation logic is concerned.
At least a couple of other aspects complicate matters further for our trusted elevator:
•	Several elevators are probably working together to transport people between the different floors. They consequently need a "team" approach to fulfill as many requests as possible. Densely populated buildings with large amounts of traffic between floors require approximately two elevators for every three floors. Thus, a 60-floor building would require about 40 elevators.
•	Certain floors are more likely to be visited and have pick-me-up requests than other floors. These probabilities might vary throughout the day. If the elevators can somehow remember these patterns, they can optimize the efficiency of the sequence of floors visited.
Sophisticated algorithms have been constructed running inside computers that control the movements of the elevators, allowing them to serve as many people as possible, fast and efficiently.
This was a bit of elevator talk, but it leads us to an essential observation.
It is easy for a person to press a button and thereby use the hidden complex services (algorithms, engines,  gears, wires, data about current speed, maximum speed, and so on) provided by the elevator. Thus, the ignorant passenger, in terms of elevator technology, can easily utilize the services of the elevator to accomplish his or her tasks of the day.
Not only is this concealment of elevator data, algorithms, and mechanics an advantage for travelers who do not want to deal with complex matters that are irrelevant to them; but it also improves the reliability of the elevator itself. No unauthorized and incompetent person can gain access to the inner control mechanisms of the elevator. Imagine if the elevator was equipped with a small "cockpit" where anybody traveling in the elevator could tinker with the maximum speed, or make the elevator believe it was on an incorrect floor, or force it to move to a floor other than the one calculated by its control algorithms. A chaotic situation would soon prevail.
A final advantage of segregating the buttons from the underlying elevator mechanisms is the capability of making changes to these mechanisms without altering the buttons and, hence, the way it is operated. In this way, an elevator can contain the same buttons that everyone has become accustomed to using for many years, while many underlying hardware and software upgrades have taken place to keep the system up to date.
Encapsulation in an Elevator Simulation
An elevator simulation program written in  will probably have Elevator and Person objects along with others. Even though now inside a computer program, a Person object will still be able to perform the equivalent of "pressing the button" of an Elevator object and giving it a floor request.
Each Elevator object of the simulation probably contains, like its real counterpart, many complex methods and many sensitive data. For example, many Elevator objects might, to make the simulation particularly realistic, be equipped with algorithms (similar to the algorithms of real world elevators) to calculate the most efficient sequence of floors visited.
Now the important analogy—each Person object (and the programmer implementing it) of the simulation should still not need or be allowed to "know" about the inner complexities (source code) of any Elevator object. All they should "care" about, just like their real counterparts, is to get from one floor to another. They don't want to be confused about unnecessary complexities either. They should not be allowed to tinker with the inner workings (data and source code) of the Elevator object, and the programmers implementing the elevator should be able to change and upgrade the source code without interfering with how the Elevator object is used (operated).
To accomplish this concealment in the OO world, we say that we encapsulate (hide) the underlying data and source code that is irrelevant for all but the Elevator objects themselves.
A Person object needs somehow the ability to "express" its floor request. A method with this capacity could arbitrarily be called NewFloorRequest which should be a public method in Elevator. The Elevator object, like its real counterpart, might need to somehow keep track of, for example, the speed at which it is traveling and its maximum speed; these are the instance variables (data) of the object, as mentioned previously. The Elevator object does not want any interference from other objects to mistakenly change their instance variables. Therefore, the Elevator objects declare them to be private, making them inaccessible for other objects.
b) an automated voice-mail system, we should be able to change the component that handles storing the messages without affecting other parts of the system. For example, we might want to increase the number of messages that a user can store. If the message-storing system has been properly hidden and isolated, this change should not affect how users access the system and leave or retrieve messages.
c) How coffee vending machine works ?
You dropped in the coin, and the coffee came out of the machine in a beautiful coffee cup. So, why didn’t you see how the where the coffee beans, how it is prepared? You really don’t know (unless you are the one who designed the machine)  how things are made inside the machine, but finally you get a coffee!! Here  don’t you see a sense of Encapsulation? So, here what is actually hidden is ,  the way how the coffee prepared .
So, Encapsulation is hiding of process; hence you hide the data. Not the vice versa.
From the definition, Encapsulation is “Information Hiding”, the information is how something is happening inside an object? It’s just a mere data hiding concept (though it includes data hiding).
So, when you model this coffee vending machine, you don’t want to show out the way how a coffee is made.  So, you don’t want to show where the coffee beans, milk and the sugar are !
 
So, in the CofeeVendingMachine class, prepareCoffee() is hidden and getCoffee() is made public, so that you will be able to send a request to the machine.
Since you have hidden the process, you don’t have any need to show how the coffee & milk are mixed and how it’s been brewed. 
 
The Coffee Vending Machine encapsulates the internal process and the ingredients (data) used in the process.
8) What is the relationship between abstraction and encapsulation?
Ans:- abstraction focuses upon the  observable behavior of an object, whereas encapsulation focuses upon the implementation that gives rise to this behavior. abstraction is a perspective and encapsulation is implementation to achieve that perspective.
9) What is Generalization and Specialization?
Ans:- Generalization is the process of extracting shared characteristics from two or more classes, and combining them into a generalized superclass , e.g. Saving , Current and FD are having some common traits. Hence we can have a base class “Saving” which will contain common traits and then all the sub classes can inherit them.
 While specialization means creating new subclasses from an existing class. If it turns out that certain attributes, associations, or methods only apply to some of the objects of the class, a subclass can be created.e.g. Flexi-Deposit is same as FD hence we can derive it from FD and have some unique traits inside it.
Both concepts can be implemented using inheritance only. But the order of creation of the subclass and the superclass drives the concept name.
The way or perspective of looking also gives the difference between these two concepts. When you look from the perspective of a base class, it is generalization because the base class has functions or operations that may be commonly used by all of its subclasses. When you look from the perspective of the derived class, it is specialization because even though the common functionalities from the super class are available, the derived classes perform their own operations or functions specific to the purpose of their creation.



 


From the above figure, if you see from the perspective of the Train, then it is Generalization. The common functions or operations of both the Passenger and Goods Trains are put into the Train such as startTrain, stopTrain, fillFuel. That is, the generic operations of any subclass of Train are included in Train.


If you see from the perspective of the subclasses (Passenger Train or Goods Train), then it is Specialization. The common functions of the superclass (Train) are also included with the specific functions of the subclass such as boardPassengers, fillWater, fillPantryResources in case of Passenger train and loadGoods, unloadGoods in case of Goods train making the subclass, a class for a specific or special function.

Note: In case of Generalization, it is not necessary that the superclass (Train) should know about the existence of its subclasses (Passenger Train and Goods Train). In case of Specialization, the subclass will always know its superclass.

10) Explain Association, Aggregation and Composition.
Ans:-             Association is a relationship where all object have their own lifecycle and there is no owner. Let’s take an example of Teacher and Student. Multiple students can associate with single teacher and single student can associate with multiple teachers but there is no ownership between the objects and both have their own lifecycle. Both can create and delete independently.
 
            Aggregation is a specialize form of Association where all object have their own lifecycle but there is ownership and child object cannot belongs to another parent object. Let’s take an example of Department and teacher. A single teacher cannot belongs to multiple departments, but if we delete the department teacher object will not destroy. We can think about “has-a” relationship.
 
            Composition is again specialize form of Aggregation and we can call this as a “death” relationship. It is a strong type of Aggregation. Child object does not have their lifecycle and if parent object deletes all child object will also be deleted. Let’s take again an example of relationship between House and rooms. House can contain multiple rooms there is no independent life of room and any room cannot belongs to two different house if we delete the house room will automatically delete. Let’s take another example relationship between Questions and options. Single questions can have multiple options and option can not belong to multiple questions. If we delete questions options will automatically delete.

11) Explain Object Composition vs Inheritance.
Ans:- Object Composition vs. Inheritance
Object composition and inheritance are two techniques for reusing functionality in object-oriented systems.

 

Class inheritance, or sub classing, allows a subclass' implementation to be defined in terms of the parent class' implementation. This type of reuse is often called white-box reuse. This term refers to the fact that with inheritance, the parent class implementation is often visible to the subclasses. 

Object composition is a different method of reusing functionality. Objects are composed to achieve more complex functionality. This approach requires that the objects have well-defined interfaces since the internals of the objects are unknown. Because objects are treated only as "black boxes," this type of reuse is often called black-box reuse.

Pros and Cons
	The advantage of class inheritance is that it is done statically at compile-time and is easy to use. The disadvantage of class inheritance is that the subclass becomes dependent on the parent class implementation. This makes it harder to reuse the subclass, especially if part of the inherited implementation is no longer desirable. Another problem with class inheritance is that the implementation inherited from a parent class cannot be changed at run-time.

	In object composition, functionality is acquired dynamically at run-time by objects collecting references to other objects. The advantage of this approach is that implementations can be replaced at run-time. This is possible because objects are accessed only through their interfaces, so one object can be replaced with another just as long as they have the same type. In addition, since each object is defined in terms of object interfaces, there are less implementation dependencies. The disadvantage of object composition is that the behaviour of the system may be harder to understand just by looking at the source code. A system using object composition may be very dynamic in nature so it may require running the system to get a deeper understanding of how the different objects cooperate. 


How inheritance can be dangerous?
 

Let’s take an example 

 public class X{

   public void do(){

    }

}

Public Class Y extends X
{
   public void work()
{
       do();
}
}

 As clear in above code , Class Y has very strong coupling with class X. If anything changes in superclass X , Y may break dramatically. Suppose In future class X implements a method work with below signature

public int work()
{

}


Change is done in class X but it will make class Y break. So this kind of dependency can go up to any level and it can be very dangerous. Every time superclass might not have full visibility to code inside all its subclasses and subclass may be keep noticing what is happening in superclass all the time. So we need to avoid this strong and unnecessary coupling.



How does composition solve this issue? 

Let’s see by revising the same example 

public class X
{
   public void do()
  {

  }
}

Public Class Y
{
    X x=new X();

public void work()
{

    x.do();

}

}

Here we are creating reference of X class in Y class and invoking method of X class by creating an instance of X class. 
Now all that strong coupling is gone. Superclass and subclass are highly independent of each other now. Classes can freely make changes which were dangerous in inheritance situation.


Second very good advantage of composition in that It provides method calling flexibility For example 

interface R
{
       void do();
}
class X implements R
{
   void do()
  {
      Do it in a X way
  }
}
class Y implements R
{
   void do()
  {
      Do it in a Y way
  }
}


 class App
{
    R ref;
    public App(R ref)
    {
       this.ref=ref;
    }

    public void work()
   {

       ref.do();   //  black-box reuse

   }
}

public class Demo
{
        public static void main(String args[])
{
R  ob1=new  X();
App first=new App(ob1);
first.work();
                        ob1=new  Y();
App second=new App(ob1);
            second.work();
          }

In App class using ref reference we can invoke methods of X class as well as Y class. This flexibility was never there in inheritance



Good to know: 
        1. composition is easily achieved at runtime while inheritance provides its features at                     compile time 

        2. composition is also known as HAS-A relation and inheritance is also known as IS-A                     relation


Example – Combining Inheritance and Composition

class FourWheeler
{
	void start()
	{
		// some default behavior
	}
	void stop()
	{
		// some default behavior
	}
}
interface Engine
{
	void start();
	void stop();
}
class MarutiEngine implements Engine
{
	@Override
	public void start() 
	{
		// maruti specifics
	}

	@Override
	public void stop() 
	{
		// maruti specifics
	}
}
class ToyotaEngine implements Engine
{
	@Override
	public void start() 
	{
		// Toyota specifics
	}

	@Override
	public void stop() 
	{
		// Toyota specifics
	}
}
class Car extends FourWheeler
{
	private Engine engine; // program to interface
	private String type;
	public Car(String type)
	{
		this.type=type;
		engine=new MarutiEngine();
	}
	void start()
	{
		super.start();
		engine.start();  //  black-box reuse
	}
	void stop()
	{
		super.stop();
		engine.stop();  //  black-box reuse
	}
}
public class Demo1 
{
	public static void main(String[] args) 
	{
		Car mycar=new Car("Maruti");
		mycar.start();
		// some more statements
		
		mycar.stop();
	}
}


12) What is polymorphism?
Ans:- Polymorphism is an ability to appear in many forms. It refers to the ability of the system to call correct implementation of methods with the same name.
Example 1

						Account

							getRateOfInterest()   // method


			SavingAccount    CurrentAccount    FixedDeposit  RecurringDeposit    //  overriding “getRateOfInterest()”  method.


			A method  “calcInterest( Account ref ) “

The above method, “pass   type of account ( Saving/Current/FD/RD ) [ upcasting ]”  . The method will calculate interest for that particular account type. [ late binding ]


Example 2:-
An  abstract class called "Animal".

On it Animal has a method called "MakeASound". Now, since Animal is abstract - there is no code inside of the MakeASound method because Animal expects a more specific type to define how MakeASound works.

So lets say you make a "Dog" class that inherits the "Animal" class. Because Dog inherits Animal - Dog is required to define functionality for the MakeASound method. Inside that method for Dog, you would put "Console.WriteLine("Bark");"

Now let's say you have a "Cat" class. Inside the MakeASound method for the cat class you would put "Console.WriteLine("Meow");"

	A method “checkSound(Animal ref) “ can take any animal (Dog/Cat ) [ upcasting ].
Using ref, we will invoke “MakeASound()” method (late binding), which will correctly invoke the method of the object we have passed.




14) What do u mean by Binding? What is the difference between Early Binding and Late Binding?
Ans:	-  Binding refers to resolving function call by function body/definition.
Early vs. Late binding
Early binding refers to resolving function call by function body/definition at compile time. e.g. normal function calls, overloading of functions and operator.
The main advantage to early binding is efficiency. Because all information necessary to call a function is determined at compile time, these types of function calls are very fast.

late binding refers to resolving function call by function body/definition at runtime. Virtual functions are used to achieve late binding. The object and the function are not linked until runtime. The main advantage of late binding is flexibility.
 However because a function call is not resolved until runtime, late binding can make for somewhat slower execution times.
15) What is Loose Coupling and tight Coupling?
Ans:- Coupling is the degree to which one object knows about another object. If the only knowledge that object A has about object B, is what B has exposed through its interface (Program to interface), then object A and object B are said to be loosely coupled... on the other hand, object A relies on object B’s implementation (Program to implementation), then A and B are said to be tightly coupled.

class Car extends FourWheeler
{
	private MarutiEngine engine=new MarutiEngine; // tight coupling , program to implementation
}

class Car extends FourWheeler
{
	private Engine engine; // loose coupling , program to interface
public Car(Engine engine) // can be provided with any implementation during runtime.
{
		This.engine=engine;
}
}

16) What is Cohesion?
Ans:- cohesion is all about how a single class is designed. The term "cohesion" is used to indicate the degree to which a class has a single, well-focused purpose. Cohesion is a subjective concept. The more focused a class is, the higher its cohesiveness - a good thing. The key benefit of high cohesion is that such classes are typically much easier to maintain (and less frequently changed) than classes with low cohesion. Another benefit of high cohesion is that classes with a well-focused purpose tend to be more reusable than other classes. 

17) What is early binding ? give examples.
Ans:- when method call is resolved by method body/definition during compile/linking time, it is known as early binding. E.g.
Operator overloading and function overloading.
4)	How composition is better than inheritance?
Ans:- Favour composition over inheritance is a one of the popular object oriented design principle, which helps to create flexible and maintainable code in object oriented languages. 



1) In case of extending a class, you only get facilities which are available at compile time.

e.g:
Class FileReader
{
Read()
{
// code to read from file
}
}
Class FileWriter
{
Write()
{
// code to write to file
}
}

Class MyApplication:FileWriter, FileReader
{

	Perform()
	{
		Read() // of FileReader   // tight coupling
		Write() // of FileWriter  // tight coupling
	}
}

drawbacks:

•	Tight coupling- if base class ( FileReader or FileWriter) is changed, sub class (MyApplication) will break.
•	inheritance breaks encapsulation. white-box reuse. That is ,with inheritance, the parent class implementation is often visible to the subclasses.

2) Composition offers better test-ability of a class than Inheritance. If one class is composed of another class, you can easily create Mock Object representing composed class for the sake of testing. Inheritance doesn't provide this luxury. In order to test derived class, you must need its super class. Since unit testing is one of the most important thing to consider during software development, especially in test driven development, composition wins over inheritance.

e.g.

interface Reader
{
		Void read();
}
Interface Writer
{
		Void write();
}
Class FileReader implements Reader
{
		Void read()
		{
			Code to read from file
		}
}
Class FileWriter implements Writer
{
		Void write()
		{
			Code to write to file
		}
}

Class MyApplication
{
		// program to interface, enables loose coupling
		Reader ref1; 
		Writer ref2;

Public MyApplication(Reader ref1,Writer ref2)
{
This.ref1=ref1;
This.ref2=ref2;
}

Void perform()
{
Ref1.read(); // late binding
Ref2.write(); // late binding
}
}

In the above example “MyApplication” is composed of “Reader” and “Writer”.

Advantages:
•	 black-box reuse as it does not break encapsulation. MyApplication knows only selected functionalities from “Reader” and “Writer”.
•	Loose coupling, program to interface. During runtime any implementations (such as “FileReader” or “SocketReader”  and “FileWriter” or “SocketWriter”) can be passed to “Reader” or “Writer” respectively and “read()” method can be invoked on it polymorphically.

Most of the  object oriented design patterns mentioned by Gang of Four favour Composition over Inheritance. 

In short, don't use Inheritance just for the sake of code reuse, Composition allows more flexible and extensible mechanism to reuse the code.
Though there are certainly some cases where using Inheritance makes much sense like when a genuine parent child relation exists, but most of time it makes sense to favour composition over inheritance for code reuse. 

13) What is method overloading?
Ans:- defining more than one functions with the same name but with different arguments is known as “Method Overloading”
e.g.
Account  class

openAccount(int accno)  //  to allow zero balance account.

openAccount(int accno,double balance)   // open account with some balance.
Another example:
Let’s say Samsung mobile have the 5MP camera available i.e. – it is having a functionality of CameraClick(). Now same mobile is having Panorama mode available in camera, so functionality would be same but with mode.

1.	public class Samsumg : Mobile  
2.	{  
3.	    public void GetWIFIConnection()  
4.	    {  
5.	        Console.WriteLine("WIFI connected");  
6.	    }  
7.	  
8.	    //This is one mwthod which shows camera functionality  
9.	    public void CameraClick()  
10.	    {  
11.	        Console.WriteLine("Camera clicked");  
12.	    }  
13.	  
14.	    //This is one overloaded method which shows camera functionality as well but with its camera's different mode(panaroma)  
15.	    public void CameraClick(string CameraMode)  
16.	    {  
17.	        Console.WriteLine("Camera clicked in " + CameraMode + " Mode");  
18.	    }  
19.	}  


So, in this example, CameraClick() method is overloaded.

12)	What are Overriding rules in java?
Ans:- there are 4 rules for overriding in java. 
1) Arguments must be same otherwise it becomes "overloading".
2) Return type of overriding can be co-variant.
3) Overriding method must be having same or more accessibility as compare to overridden method.
4) Overriding and checked-exception rule :

a) Overriding method may not declare any checked exception.
b) Overriding method can declare same checked exception or its sub-type declared by overridden method.
c) Overriding method cannot declare checked exception not declared by overridden method.
15) what is “black-box-reuse” and “white-box-reuse”?
Ans: Class inheritance, or sub classing, allows a subclass' implementation to be defined in terms of the parent class' implementation. This type of reuse is often called white-box reuse. This term refers to the fact that with inheritance, the parent class implementation is often visible to the subclasses. 

Object composition is a different method of reusing functionality. Objects are composed to achieve more complex functionality. This approach requires that the objects have well-defined interfaces since the internals of the objects are unknown. Because objects are treated only as "black boxes," this type of reuse is often called black-box reuse.


1)	What Is an Exception?
Ans:- An exception is an event, which occurs during the execution of a program, that interrupts the normal flow of the program's instructions.
4)	What is the difference between “Exception” and “Error”?
Ans:- 
Both Error and Exception are derived from java.lang.Throwable. 
Examples of Error are:
java.lang.OutOfMemoryError or Java.lang.NoClassDefFoundError  java.lang.UnSupportedClassVersionError etc.
examples of Exception are:
java.lang.RuntimeException (unchecked) , java.io.IOException (checked) etc.
The first difference is Error is unchecked by nature whereas Exceptions can be checked or unchecked.
The second difference is that Error is not meant to catch as even if you catch it you cannot recover from it. For example during OutOfMemoryError, if you catch it you will get it again because GC may not be able to free memory in first place. On the other hand Exception can be caught and handled properly.
i.e. Errors are fatal in nature and recovery may not be possible, on the other hand by carefully handling Exception you can make your code more robust and guard against different scenarios.

An exception is an event that represents a condition from which is possible to recover, whereas error represents an external situation usually impossible to recover from.
All errors thrown by the JVM are instances of Error or one of its subclasses, the more common ones include but are not limited to:
•	OutOfMemoryError – thrown when the JVM cannot allocate more objects because it is out memory, and the garbage collector was unable to make more available
•	StackOverflowError – occurs when the stack space for a thread has run out, typically because an application recurses too deeply
•	ExceptionInInitializerError – signals that an unexpected exception occurred during the evaluation of a static initializer. E.g.
public class MyClass
2)	Why do we need Exceptions?
Ans:

Advantages of Exceptions

Advantage 1: Separating Error-Handling Code from "Regular" Code

Exceptions provide the means to separate the details of what to do when something out of the ordinary happens from the main logic of a program. In traditional programming, error detection, reporting, and handling often lead to confusing code. For example, consider the pseudo code method here that reads an entire file into memory.

readFile {
    open the file;
     allocate that much memory;
    read the file into memory;
    close the file;
}
At first glance, this function seems simple enough, but it ignores all the following potential errors.

What happens if the file can't be opened?
What happens if enough memory can't be allocated?
What happens if the read fails?
What happens if the file can't be closed?

To handle such cases, the readFile function must have more code to do error detection, reporting, and handling. Here is an example of what the function might look like.

errorCodeType readFile {
    initialize errorCode = 0;
    
    open the file;
    if (theFileIsOpen) {
        determine the length of the file;
            if (gotEnoughMemory) {
                read the file into memory;
                if (readFailed) {
                    errorCode = -1;
                }
            } else {
                errorCode = -2;
            }
        } else {
            errorCode = -3;
        }
        close the file;
        if (theFileDidntClose && errorCode == 0) {
            errorCode = -4;
        } else {
            errorCode = errorCode and -4;
        }
    } else {
        errorCode = -5;
    }
    return errorCode;
}
There's so much error detection, reporting, and returning here that the original seven lines of code are lost in the clutter. Worse yet, the logical flow of the code has also been lost, thus making it difficult to tell whether the code is doing the right thing: Is the file really being closed if the function fails to allocate enough memory? Many programmers solve this problem by simply ignoring it — errors are reported when their programs crash.

Exceptions enable you to write the main flow of your code and to deal with the exceptional cases elsewhere. If the readFile function used exceptions instead of traditional error-management techniques, it would look more like the following.

readFile {
    try {
        open the file;
        determine its size;
        allocate that much memory;
        read the file into memory;
        close the file;
    } catch (fileOpenFailed) {
       doSomething;
    }  catch (memoryAllocationFailed) {
        doSomething;
    } catch (readFailed) {
        doSomething;
    } catch (fileCloseFailed) {
        doSomething;
    }
}
Note that exceptions don't spare you the effort of doing the work of detecting, reporting, and handling errors, but they do help you organize the work more effectively.

Advantage 2: Propagating Errors Up the Call Stack

A second advantage of exceptions is the ability to propagate error reporting up the call stack of methods. Suppose that the readFile method is the fourth method in a series of nested method calls made by the main program: method1 calls method2, which calls method3, which finally calls readFile.

method1 {
    call method2;
}

method2 {
    call method3;
}

method3 {
    call readFile;
}
Suppose also that method1 is the only method interested in the errors that might occur within readFile. Traditional error-notification techniques force method2 and method3 to propagate the error codes returned by readFile up the call stack until the error codes finally reach method1—the only method that is interested in them.

method1 {
    errorCodeType error;
    error = call method2;
    if (error)
        doErrorProcessing;
    else
        proceed;
}

errorCodeType method2 {
    errorCodeType error;
    error = call method3;
    if (error)
        return error;
    else
        proceed;
}

errorCodeType method3 {
    errorCodeType error;
    error = call readFile;
    if (error)
        return error;
    else
        proceed;
}

A method can duck any exceptions thrown within it, thereby allowing a method farther up the call stack to catch it. Hence, only the methods that care about errors have to worry about detecting errors.

method1 {
    try {
        call method2;
    } catch (exception e) {
        doErrorProcessing;
    }
}

method2 throws exception {
    call method3;
}

method3 throws exception {
    call readFile;
}

However, as the pseudo code shows, ducking an exception requires some effort on the part of the middleman methods. Any checked exceptions that can be thrown within a method must be specified in its throws clause.

Advantage 3: Grouping and Differentiating Error Types

Because all exceptions thrown within a program are objects, the grouping or categorizing of exceptions is a natural outcome of the class hierarchy. An example of a group of related exception classes in the Java platform are those defined in java.io — IOException and its sub classes. IOException is the most general and represents any type of error that can occur when performing I/O. Its sub classes represent more specific errors. For example, FileNotFoundException means that a file could not be located on disk.

A method can write specific handlers that can handle a very specific exception. The FileNotFoundException class has no sub class, so the following handler can handle only one type of exception.

catch (FileNotFoundException e) {
    ...
}

A method can catch an exception based on its group or general type by specifying any of the exception's superclasses in the catch statement. For example, to catch all I/O exceptions, regardless of their specific type, an exception handler specifies an IOException argument.

catch (IOException e) {
    ...
}

This handler will be able to catch all I/O exceptions, including FileNotFoundException, EOFException, and so on. You can find details about what occurred by querying the argument passed to the exception handler. For example, use the following to print the stack trace.

catch (IOException e) {
    // Output goes to System.err.
    e.printStackTrace();
    // Send trace to stdout.
    e.printStackTrace(System.out);
}

You could even set up an exception handler that handles any Exception with the handler here.

// A (too) general exception handler
catch (Exception e) {
    ...
}

3)	Describe the exception hierarchy in java.
Ans:- 
 

{
	static MyClass m=null;
	static
	{
		m.disp();
	}
	public void disp()
	{
		System.out.println("in disp");
	}
	public static void main(String[] args)
	{
		System.out.println("done");
	}
}
Output: Exception in thread "main" java.lang.ExceptionInInitializerError
Caused by: java.lang.NullPointerException
	at trial.MyClass.<clinit>(MyClass.java:8)
•	NoClassDefFoundError – is thrown when the classloader tries to load the definition of a class and couldn’t find it, usually because the required classfiles were not found in the classpath
•	UnsupportedClassVersionError – occurs when the JVM attempts to read a classfile and determines that the version in the file is not supported, normally because the file was generated with a newer version of Java
Although an error can be handled with a try statement, this is not a recommended practice since there is no guarantee that the program will be able to do anything reliably after the error was thrown.


16) Give an example between tight coupling and loose coupling.
Ans:-  Program wise Difference between Tight Coupling and Loose Coupling?

Tight Coupling Between two Objects

class Traveler
{
    Car c=new Car();
    void startJourney()
    {
       c.move();
    }
}

class Car
{
  void move()
  {
     // logic...
  }
}

Loose Coupling Between two Objects

class Traveler
{
    Vehicle v;
    public void setV(Vehicle v)
    {
      this.v = v;
    }      

    void startJourney()
    {
       v.move();
    }
}
//=========================Interface====================================
 Interface Vehicle
    {
       void move();
    }
//====================Multiple class implement vehicle interface. 
First class====
class Car implements Vehicle
{
    public void move()
    {
         // logic
    }
}
//===================
Second class================
class Bike implements Vehicle
{
    public void move()
    {
         // logic
    }
}

17) Explain abstract class
Ans:- in java as soon as u define a class with "abstract" keyword, class becomes abstract.
abstract class can not be instantiated.
abstract class can contain abstract as well as non-abstract methods.
abstract method is a method which is declared with "abstract" keyword.
a child class of an abstract class has to provide implementation to the method which is declared "abstract" in parent class or else make child class also "abstract".

18) What is the need of abstract class?
Ans:- Abstract classes let you define some behaviors; they force your subclasses to provide others. For example, if you have an application framework, an abstract class may provide default services such as event and message handling. Those services allow your application to plug in to your application framework. However, there is some application-specific functionality that only your application can perform. Such functionality might include startup and shutdown tasks, which are often application-dependent. So instead of trying to define that behavior itself, the abstract base class can declare abstract shutdown and startup methods. The base class knows that it needs those methods, but an abstract class lets your class admit that it doesn't know how to perform those actions; it only knows that it must initiate the actions. When it is time to start up, the abstract class can call the startup method. When the base class calls this method, Java calls the method defined by the child class.

19) Why can’t we instantiate abstract class?
Ans:- An Abstract class represents an abstract concept. Take an example of vehicle class. You cannot build a vehicle that is not something more specific.
Abstract classes represent such abstract concepts as vehicle. Hence the idea of instantiating one doesn’t make sense because to actually instantiate it you need to know what you're instantiating.
An abstract class is not complete! The author marked it abstract to tell you that some implementation is missing in the code. The author has done some of the work, but you must fill in some bits yourself to get it working. The abstract keyword ensures that no one would accidentally initiate this incomplete class.
Because it is abstract which in simple terms means not real, or an imaginary thing. you have to make a real class that is based on the abstract ideas to be able to instantiate it.
Simply said, because it is possible that some methods are not implemented. In the case of an interface, none of the methods are implemented.

If you would be able to create an instance, and call a non-implemented method, what code should be executed? Not that of the class / interface itself, since there is no code to execute. 	

The answer of "why you can't instantiate an abstract class " is because when you use the keyword "abstract " you're saying: "I'll provide implementation details of this class in one of my child classes" 
Abstract class means incomplete class. We do not know implementations for some of the methods. So in programmatic way we are informing that at this point, I don’t know the implementation. So whoever want to use, create a concrete class. Logically this is the reason for not Instantiating the abstract class.
Abstract classes are ideas and concrete classes are things that we can describe and touch if they were in the real world.
20) Can abstract class have constructors?
Ans:- Yes, abstract class can declare and define constructor in Java. Since you cannot create instance of abstract class, constructor can only be called during constructor chaining, i.e. when you create instance of concrete implementation class. Now question arises what is the purpose of constructor, if you cannot instantiate abstract class? Well, it can still be used to initialize common variables, which are declared inside abstract class, and used by various implementations. Also even if you don’t provide any constructor, compiler will add default no argument constructor in abstract class, without that your subclass will not compile, since first statement in any constructor implicitly calls super(), default super class constructor.

21) What is “this”?
Ans:- member functions are having only one copy in memory irrespective of no. of objects created.
how does member function comes to know which object they have to work for?
Answer is "this pointer or reference".
"this" pointer or reference is a pointer pointing to current object or calling object.
when u call any member function using an object, "this" pointer or reference holds the address of that object. using "this" pointer member function will come to know to which object they have to work for. Infact when u invoke any member function compiler secretly pass first argument as “this” pointer or reference.

22) Explain static member and member function.
Ans:- static members
static members are allocated memory as soon as class is loaded. i.e. even before any object is created. Since they are not associated with objects, they are having only one copy in the memory. In order to access static member, no need to use object.
application of static member
	suppose you are designing "Account" class. accout_id,name,type and balance are different for different instances,but rate_of_interest will be common for all the objects. Hence rate_of_interest will be the static member in this case.
	if you want to keep track of number of objects created of a class, you can have static member "int cnt" which will be incremented every time object is created.

23) explain linking of Base class, Sub class and Base object, Sub object.
Ans:-  Base class and Sub class are linked i.e. if u make any changes in Base class that will reflect in Sub class. 
Base Object and Sub object are not linked. If u make any changes in base object Sub object will not be reflected.
24) How will you relate unrelated classes or how will you achieve polymorphism without using base class?
Ans:-  suppose, we have 3 objects from unrelated classes.

Vehicle					IFlying     - interface
Plane						fly()  - method

Superhero
Superman

Animal
Bird


IFlying f=list.nextObj();

Here list contains all “Plane” or “Bird” or “Superhero”  objects.

f.fly();    // late binding

this is polymorphism without using base class. i.e. using base interface.
So , with the help of “IFlying” interface, we have related all unrelated classes.
U can implement Polymorphism  through Common Interface among unrelated classes.

Apply interface when u don’t have common base class.
Apply base class when u have related classes.


25) What is Association,Aggregation and Composition?
Ans:
Association is a relationship where all object have their own lifecycle and there is no owner. Let’s take an example of Teacher and Student. Multiple students can associate with single teacher and single student can associate with multiple teachers but there is no ownership between the objects and both have their own lifecycle. Both can create and delete independently.
 
            Aggregation is a specialize form of Association where all object have their own lifecycle but there is ownership and child object cannot belongs to another parent object. Let’s take an example of Department and teacher. A single teacher cannot belongs to multiple departments, but if we delete the department teacher object will not destroy. We can think about “has-a” relationship.
 
            Composition is again specialize form of Aggregation and we can call this as a “death” relationship. It is a strong type of Aggregation. Child object does not have their lifecycle and if parent object deletes all child object will also be deleted. Let’s take again an example of relationship between House and rooms. House can contain multiple rooms there is no independent life of room and any room cannot belongs to two different house if we delete the house room will automatically delete. Let’s take another example relationship between Questions and options. Single questions can have multiple options and option cannot belong to multiple questions. If we delete questions options will automatically delete.

Aggregation is a special case of association. A directional association between objects. When an object ‘has-a’ another object, then you have got an aggregation between them.
eg: Room has a table, but the table can exist without the room.
    class Room {

      private Table table;

      void setTable(Table table) {
        this.table = table;
      }

    }
Composition is a special case of aggregation. Composition is more restrictive. When there is a composition between two objects, the composed object cannot exist without the other object. This restriction is not there in aggregation. eg: rooms in a house, which cannot exist after the lifetime of the house.
    class House {

      private  Room room;

      House(Room roomSpecs) {
        room = new Room(roomSpecs);
      }

    }


26)	What is Dependency?
When one class depends on another because it uses that at some point in time then this relationship is known as Dependency. One class depends on another if the independent class is a parameter variable or local variable of a method of the dependent class. A Dependency is drawn as a dotted line from the dependent class to the independent class with an open arrowhead pointing to the independent class.
27)	What is Diamond Problem?
Ans: Suppose we have two classes B and C inherit from A, and class D inherits from both B and C. ... now when we instantiate class D, there exists two copies of A (via B and C )inside D object. When u invoke any method of A class using object of D, it creates ambiguity that is compiler does not know u are invoking which method , the method of A available through D or C. It is called the "diamond problem”.
28)	What is the Solution for Diamond Problem?
Ans:- Suppose we have 2 classes Lion and Tiger that derive from the same class – in our example above it would be class Animal. We also have class Liger that derives from both Lion and Tiger by using multiple inheritance

/*
The Animal class below corresponds to class 
A in our graphic above
*/
								
class Animal { /* ... */ }; // base class
{
int weight;

public:

int getWeight() { return weight;};

};

class Tiger : public Animal { /* ... */ };

class Lion : public Animal { /* ... */ }	
						
class Liger : public Tiger, public Lion { /* ... */ };	
In the code above, we’ve given a more concrete example of the diamond problem. The Animal class corresponds to the topmost class in the hierarchy (A in our graphic above), Tiger and Lion respectively correspond to B and C in the graphic, and the Liger class corresponds to D.
Now, the question is what is the problem with having an inheritance hierarcy like this. Take a look at the code below so that we can best answer that question:
int main( )
{
Liger lg ;

/*COMPILE ERROR, the code below will not get past
any C++ compiler */

int weight = lg.getWeight();  
}




In our inheritance hierarchy, we can see that both the Tiger and Lion classes derive from the Animal base class. And here is the problem: because Liger derives from both the Tiger and Lion classes – which each have their own copy of the data members and methods of the Animal class- the Liger object "lg" will contain two subobjects of the Animal base class.
So, you ask, what’s the problem with a Liger object having 2 sub-objects of the Animal class? Take another look at the code above – the call "lg.getWeight()" will result in a compiler error. This is because the compiler does not know whether the call to getWeight refers to the copy of getWeight that the Liger object lg inherited through the Lion class or the copy that lg inherited through the Tiger class. So, the call to getWeight in the code above is ambiguous and will not get past the compiler.
Solution to the Diamond Problem
We’ve given an explanation of the diamond problem, but now we want to give you a solution to the diamond problem. If the inheritance from the Animal class to both the Lion class and the Tiger class is marked as virtual, then C++ will ensure that only one subobject of the Animal class will be created for every Liger object. This is what the code for that would look like:
class Tiger : virtual public Animal { /* ... */ };

class Lion : virtual public Animal { /* ... */ }

You can see that the only change we’ve made is to add the "virtual" keyword to the Tiger and Lion class declarations. Now the Liger class object will have only one Animal subobject, and the code below will compile just fine:
int main( )
{
Liger lg ;

/*THIS CODE WILL NOW COMPILE OK NOW THAT WE'VE
USED THE VIRTUAL KEYWORD IN THE TIGER AND LION
CLASS DECLARATIONS */

int weight = lg.getWeight();  
}



Top 25 Most Frequently Asked Interview Core Java Interview Questions And Answers

Top 25  Java Interview Questions :

1. Which two method you need to implement for key Object in HashMap ?
In order to use any object as Key in HashMap, it must implements equals and hashcode method in Java. Read How HashMap works in Java  for detailed explanation on how equals and hashcode method is used to put and get object from HashMap. 

2. What is immutable object? Can you write immutable object?Immutable classes are Java classes whose objects can not be modified once created. Any modification in Immutable object result in new object. For example is String is immutable in Java. Mostly Immutable are also final in Java, in order to prevent sub class from overriding methods in Java which can compromise Immutability. You can achieve same functionality by making member as non final but private and not modifying them except in constructor.

3. What is the difference between creating String as new() and literal?
When we create string with new() Operator, it’s created in heap and not added into string pool while String created using literal are created in String pool itself which exists in PermGen area of heap.



String s = new String("Test");
 
does not  put the object in String pool , we need to call String.intern() method which is used to put  them into String pool explicitly. its only when you create String object as String literal e.g. String s = "Test" Java automatically put that into String pool.


4. What is difference between StringBuffer and StringBuilder in Java ?


Classic Java questions which some people thing tricky and some consider very easy. StringBuilder in Java is introduced in Java 5 and only difference between both of them is that Stringbuffer methods are synchronized while StringBuilder is non synchronized. See StringBuilder vs StringBuffer for more differences.


5.  Write code to find the First non repeated character in the String  ?
Another good Java interview question, This question is mainly asked by Amazon and equivalent companies. See first non repeated character in the string : Amazon interview question



6. What is the difference between ArrayList and Vector ?
This question is mostly used as a start up question in Technical interviews  on the topic of Collection framework . Answer is explained in detail here Difference between ArrayList and Vector .


7. How do you handle error condition  while writing stored procedure or accessing stored procedure from java?
This is one of the tough Java interview question and its open for all, my friend didn't know the answer so he didn't mind telling me. my take is that stored procedure should return error code if some operation fails but if stored procedure itself fail than catching SQLException is only choice.


8. What is difference between Executor.submit() and Executer.execute() method ?
There is a difference when looking at exception handling. If your tasks throws an exception and if it was submitted with execute this exception will go to the uncaught exception handler (when you don't have provided one explicitly, the default one will just print the stack trace to System.err). If you submitted the task with submit any thrown exception, checked exception or not, is then part of the task's return status. For a task that was submitted with submit and that terminates with an exception, the Future.get will re-throw this exception, wrapped in an ExecutionException.


9. What is the difference between factory and abstract factory pattern?
Abstract Factory provides one more level of abstraction. Consider different factories each extended from an Abstract Factory and responsible for creation of different hierarchies of objects based on the type of factory. E.g. AbstractFactory extended by AutomobileFactory, UserFactory, RoleFactory etc. Each individual factory would be responsible for creation of objects in that genre.
You can also refer What is Factory method design pattern in Java to know more details.


10. What is Singleton? is it better to make whole method synchronized or only critical section synchronized ?
Singleton in Java is a class with just one instance in whole Java application, for example java.lang.Runtime is a Singleton class. Creating Singleton was tricky prior Java 4 but once Java 5 introduced Enum its very easy. see my article How to create thread-safe Singleton in Java for more details on writing Singleton using enum and double checked locking which is purpose of this Java interview question.


11. Can you write critical section code for singleton?
This core Java question is followup of previous question and expecting candidate to write Java singleton using double checked locking. Remember to use volatile variable to make Singleton thread-safe.

12. Can you write code for iterating over hashmap in Java 4 and Java 5 ?
Tricky one but he managed to write using while and for loop.

13. When do you override hashcode and equals() ?
Whenever necessary especially if you want to do equality check or want to use your object as key in HashMap.

14. What will be the problem if you don't override hashcode() method ?
You will not be able to recover your object from hash Map if that is used as key in HashMap.
See here  How HashMap works in Java for detailed explanation.

15. Is it better to synchronize critical section of getInstance() method or whole getInstance() method ?
Answer is critical section because if we lock whole method than every time some one call this method will have to wait even though we are not creating any object)

16. What is the difference when String is gets created using literal or new() operator ?
When we create string with new() its created in heap and not added into string pool while String created using literal are created in String pool itself which exists in Perm area of heap.

17. Does not overriding hashcode() method has any performance implication ?
This is a good question and open to all , as per my knowledge a poor hashcode function will result in frequent collision in HashMap which eventually increase time for adding an object into Hash Map.

18. What’s wrong using HashMap in multithreaded environment? When get() method go to infinite loop ?
Another good question. His answer was during concurrent access and re-sizing.

19.  What do you understand by thread-safety ? Why is it required ? And finally, how to achieve thread-safety in Java Applications ? 

Java Memory Model defines the legal interaction of threads with the memory in a real computer system. In a way, it describes what behaviors are legal in multi-threaded code. It determines when a Thread can reliably see writes to variables made by other threads. It defines semantics for volatile, final & synchronized, that makes guarantee of visibility of memory operations across the Threads.

Let's first discuss about Memory Barrier which are the base for our further discussions. There are two type of memory barrier instructions in JMM - read barriers and write barrier.

A read barrier invalidates the local memory (cache, registers, etc) and then reads the contents from the main memory, so that changes made by other threads becomes visible to the current Thread.
A write barrier flushes out the contents of the processor's local memory to the main memory, so that changes made by the current Thread becomes visible to the other threads.
JMM semantics for synchronized
When a thread acquires monitor of an object, by entering into a synchronized block of code, it performs a read barrier (invalidates the local memory and reads from the heap instead). Similarly exiting from a synchronized block as part of releasing the associated monitor, it performs a write barrier (flushes changes to the main memory)
Thus modifications to a shared state using synchronized block by one Thread, is guaranteed to be visible to subsequent synchronized reads by other threads. This guarantee is provided by JMM in presence of synchronized code block.

JMM semantics for Volatile  fields
Read & write to volatile variables have same memory semantics as that of acquiring and releasing a monitor using synchronized code block. So the visibility of volatile field is guaranteed by the JMM. Moreover afterwards Java 1.5, volatile reads and writes are not reorderable with any other memory operations (volatile and non-volatile both). Thus when Thread A writes to a volatile variable V, and afterwards Thread B reads from variable V, any variable values that were visible to A at the time V was written are guaranteed now to be visible to B.


Let's try to understand the same using the following code


Data data = null;
volatile boolean flag = false;


Thread A
-------------
data = new Data();
flag = true;  <-- writing to volatile will flush data as well as flag to main memory


Thread B
-------------
if(flag==true){ <-- as="" barrier="" data.="" flag="" font="" for="" from="" perform="" read="" reading="" volatile="" well="" will="">
use data;  <!--- data is guaranteed to visible even though it is not declared volatile because of the JMM semantics of volatile flag.
}

20.  What will happen if you call return statement or System.exit on try or catch block ? will finally block execute?
This is a very popular tricky Java question and its tricky because many programmer think that finally block always executed. This question challenge that concept by putting return statement in try or catch block or calling System.exit from try or catch block. Answer of this tricky question in Java is that finally block will execute even if you put return statement in try block or catch block but finally block won't run if you call System.exit form try or catch.


19. Can you override private or static method in Java ?
Another popular Java tricky question, As I said method overriding is a good topic to ask trick questions in Java.  Anyway, you can not override private or static method in Java, if you create similar method with same return type and same method arguments that's called method hiding. 



20. What will happen if we put a key object in a HashMap which is already there ?
This tricky Java questions is part of How HashMap works in Java, which is also a popular topic to create confusing and tricky question in Java. well if you put the same key again than it will replace the old mapping because HashMap doesn't allow duplicate keys. 


21. If a method throws NullPointerException in super class, can we override it with a method which throws RuntimeException?
One more tricky Java questions from overloading and overriding concept. Answer is you can very well throw super class of RuntimeException in overridden method but you can not do same if its checked Exception. 

22. What is the issue with following implementation of compareTo() method in Java


public int compareTo(Object o){
   Employee emp = (Employee) emp;
   return this.id - o.id;
}



23. How do you ensure that N thread can access N resources without deadlock
If you are not well versed in writing multi-threading code then this is real tricky question for you. This Java question can be tricky even for experienced and senior programmer, who are not really exposed to deadlock and race conditions. Key point here is order, if you acquire resources in a particular order and release resources in reverse order you can prevent deadlock. 


24. What is difference between CyclicBarrier and CountDownLatch in Java
Relatively newer Java tricky question, only been introduced form Java 5. Main difference between both of them is that you can reuse CyclicBarrier even if Barrier is broken but you can not reuse CountDownLatch in Java. See CyclicBarrier vs CountDownLatch in Java for more differences.

25. Can you access non static variable in static context?
Another tricky Java question from Java fundamentals. No you can not access static variable in non static context in Java. Read why you can not access non-static variable from static method to learn more about this tricky Java questions.






1)	 What is Java?
Ans:- Java technology is both a programming language and a platform from Oracle Corporation.
2)	Why Java is called as “Platform”?
ans:- A platform is basically the hardware or software environment in which a program runs. Java provides software-based platform i.e. JVM, which can run applications developed using the Java Programming Language.

 

3)	What are the features of Java ?
Ans:- Features of Java

1) Simple
Simple syntax. No pointers, no multiple inheritance with the classes which causes ambiguity error. For almost every task API (Application Programming Interface) is available; Programmer just need to know how to use that API. 

2) Object Oriented
Java is strong object oriented as it does not allow features like global data, friend function which are against OOP principles.

3) Automatic Garbage Collection:
Automatic garbage collection is the process of looking at heap memory, identifying which objects are in use and which are not, and deleting the unused objects. An in use object, or a referenced object, means that some part of your program still maintains a reference to that object. An unused object, or unreferenced object, is no longer referenced by any part of your program. So the memory used by an unreferenced object can be reclaimed.

3) Robust
Robust means safe. Java puts a lot of emphasis on early checking for possible errors, as Java compilers are able to detect many problems that would first show up during execution time in other languages. 
It provides the powerful exception handling and type checking mechanism as compare to other programming languages. 

4) Platform Independent
Unlike other programming languages such as C, C++ etc which are compiled into platform specific machines. Java is guaranteed to be compile-once, run-anywhere language.
On compilation Java program is compiled into bytecode. This bytecode is platform independent and can be run on any machine. Any machine with Java Runtime Environment can run Java Programs.












5) Secure
If a bytecode contains any virus or malicious code, JVM will not execute it. This features saves your system especially when u download java code and try to execute.

6) Multi Threading
Java multithreading feature makes it possible to write program that can do many tasks simultaneously. 

7) Portable
Java Byte code can be carried to any platform. 

8) Architectural Neutral
No implementation dependent features. Everything related to storage is predefined, example: size of primitive data types is same on all the platforms.

8) High Performance
Java enables high performance with the use of Just-In-Time (JIT) compiler.

4)	How java is platform independent ?
Ans:- Java program, once compiled , can be run on any platform without recompiling.


















5)	Which version of java have u learned? Name some of the new features added to it.
Ans:- java8 version. Some of the new features are:

	default methods  and  static methods inside interface

	lambda expressions

	method reference

	stream api

6) What is native code?
Ans:- Native code is computer programming (code) that is compiled to run with a particular processor (such as an Intel x86-class processor) and its set of instructions. 

6)	What is the difference bet’n  JDK and JRE.
 
JRE is an acronym for Java Runtime Environment. It is used to provide runtime environment. It contains JVM + API ( jars and dlls)
JDK is an acronym for Java Development Kit. It contains JRE + development tools like compiler,debugger etc.

7)	What is JVM ? What it does?
Ans:-  A Java virtual machine (JVM), an implementation of the Java Virtual Machine Specification, interprets compiled Java binary code (called bytecode) for a computer's processor (or "hardware platform") so that it can perform a Java program's instructions. Java was designed to allow application programs to be built that could be run on any platform without having to be rewritten or recompiled by the programmer for each separate platform.
JVMs are available for various platforms (i.e.JVM is platform dependent).

It is:
1.A specification where working of Java Virtual Machine is specified. But implementation provider is independent to choose the algorithm. Its implementation has been provided by Sun and other companies.
2.An implementation Its implementation is different for different platforms.
3.Runtime Instance Whenever you write java command on the command prompt to run the java class, an instance of JVM is created.

The JVM performs following operation:
•Loads code
•Verifies code
•Executes code

8)	 Why JVM is called as “virtual machine”?
Ans:- The JVM is "virtual" because it is generally implemented in software on top of a "real" hardware platform and operating system. All Java programs are compiled for the JVM. Therefore, the JVM must be implemented on a particular platform before compiled Java programs will run on that platform.

9)	What is the lifetime of Java Virtual Machine ?
Ans:- When a Java application starts, a runtime instance of JVM is born. When the application completes, the instance dies.

10)	What are the main components of JVM? Explain them. Or Explain JVM Architecture.
Ans:-  a) ClassLoader Subsystem  b) Various Runtime Data Areas  	c) Execution Engine
Class loader Subsystem:
	
		Several parts
			Loading
			Linking [ verify,prepare and resolve ]
			Initializing

a)	Loading
BootStrap class loader
		Load classes from “rt.jar” ie. All core java API classes are loaded.

Extension class loader
	Loads classes from “ext” folder. 	
Application class loader
	Loads classes from application level class path – set inside environment

Amongst all these “BootStrap class loader” will get highest priority.  If “BootStrap class loader is unable to load classes then “Extension class loader” will load the the classes. If “Extension class loader” is also unable to load class file, then, “application class loader” will try to load the class file.

b)	Linking
Verify
	BytecodeVerifier is going to check whether ur generated bytecode is proper or not. Ie. Whether it contains any virus or malicious code and whether class file format is compatible with JVM class specification. If verification fails then we will get “Verify Error”. Java program is always secure. You can execute on any machine happily because Bytecode Verifier is going to take care ,is it valid or not.

Prepare
	For static variables memory will be allocated and assigned with the default values. ( not the values u have initialized with)
Resolve
	It is eager resolution if any. 
c)	Initialization
Static variables are assigned with the values u have initialized. Static blocks are executed in the textual order.
After Initialization only “class loading” completed successfully by “Class Loader SubSystem”.

ClassNotFoundException :- happens when class loader fails to find the bytecodes correspond to a class we mention.
ClassDefNotFoundException:- happens during a “Resolve” phase.  E.g  if we say
Java X
	Now X will be loaded, verified , prepared. Next step is resolve. Suppose class X contains reference of class Y, resolve phase will try to find out Y.class. if class Y can not be found exception will be thrown “ClassDefNotFoundException” for X which wraps “ClassNotFoundException” for Y.

Consider following example:

public class X
{
	Y ref;
	public static void main(String args[])
	{
		X ob=new X();
		ob.ref=new Y();
	}
}
class Y
{
}

After compiling X.java we will get two .class files
X.class and Y.class
if we delete “Y.class” and execute application by saying 
java X
we will get following error:

Exception in thread "main" java.lang.NoClassDefFoundError: Y
        at X.main(X.java:7)
Caused by: java.lang.ClassNotFoundException: Y

when u say  
java Sample,  Sample.class is an input to “ClassLoaderSubsytem”.
In short, ClassLoaderSubsytem is responsible to load our classes. In order to load the classes, some memory is required.
There are various Runtime DataAreas present inside JVM.
a)	Method area:- will consists of following things:
class bytecode
class loader who loads the class information
reference to class Class
static variables
various literals (String,Integer,float etc)

Type Information
For each type it loads, a Java virtual machine must store the following kinds of information in the method area:
•	The fully qualified name of the type
•	The fully qualified name of the type's direct superclass (unless the type is an interface or class java.lang.Object, neither of which have a superclass)
•	Whether or not the type is a class or an interface
•	The type's modifiers ( some subset of` public, abstract, final)
•	An ordered list of the fully qualified names of any direct super-interfaces


Method Information
For each method declared in the type, the following information must be stored in the method area. As with fields, the order in which the methods are declared by the class or interface must be recorded as well as the data. Here's the list:
•	The method's name
•	The method's return type (or void)
•	The number and types (in order) of the method's parameters
•	The method's modifiers (some subset of public, private, protected, static, final, synchronized, native, abstract)

Since Java8, there is no “Method Area” , Now it is called as “metaspace”. 
b)	Heap area:- objects and corresponding instance variables will be stored in heap area. 

Method area and Heap area are per JVM.

c)	Stack area:- for every thread a separate runtime stack will be created. Each entry (method name) in the stack is called as “Stack frame”. For every thread, one runtime stack is there.
So if inside JVM 10 threads are running, 10 stacks are there.
The data which is stored inside “Stack Memory” is always a “Thread-Safe”.
It is because that data is available only for that thread not for other thread and vice-versa.
	In case of recursive function if u forget to put a condition it goes into infinite loop. That is it will go on creating stack frame over stack frame over stack frame…………..  That means u will go out of space in stack area memory and u will get “java.lang.StackOverflowError”

d)	PC register:- Program Counter Register
Every thread has got a different PC register which stores pointer to next line to be executed by JVM.
i.e. to hold address of next executing instruction.
Suppose u r running three threads T1,T2 and T3.
In this case there will be 3 program counters each for T1, T2 and T3.
e)	Native method stack:- if threads are invoking any native method, then for every thread a different stack will be created inside native method stack.


PC registers, Stack and Native Method Stack are per thread. So Thread1 can’t see what is there in stack frame created for Thread2 and vice-versa. That means whatever happens in method execution generally is thread-safe. 
At the same time “Method Area  or metaspace(in java8) “ and “heap area” are not per thread. These are created per JVM.

Execution engine:- 
execution area will communicate with “Memory areas”.
i.e. once a data area is loaded which is an instruction to be executed, i.e. current instruction to be executed is ready ( using PC register) what happens is that “Java Interpreter” interprets the current instruction that is there in the bytecode and executes it. 
Execution Engine has 4 components
(i)	Interpreter  (ii)  JIT Compiler  (iii)  HotSpot profiler   (iv)  GC
1. Interpreter
It is responsible to read byte code and interpret into machine code (native code) and execute that machine code line by line. The problem with interpret is it interprets every time even some method invoked multiple times which effects performance of the system. To overcome this problem SUN people introduced JIT compilers in 1.1 V.
2. JIT Compiler
The JIT compiler has been introduced to compensate for the disadvantages of the interpreter. The main purpose of JIT compiler is to improve the performance. Whenever JVM across any method call, first that method will be interpreted normally by the interpreter but if that method is a repeatedly used (called) method (Hotspot), immediately JIT compiler compiles that method and generates corresponding native code. Next time JVM come across that method call then JVM directly uses native code and executes it instead of interpreting once again, so that performance of the system will be improved. 
Profiler which is the part of JIT compiler is responsible to identify Hotspot (Repeated Used Methods).


There are other components also inside “Execution Engine”  
	Garbage Collector
	Security manager
When JIT compiler will come into picture?
If a method is repeatedly invoked methods. 
Who is going to take care whether it is repeatedly required method or Hotspot method ?
	Hotspot Profiler is responsible to identify whether method is repeatedly required ( i.e. it is HotSpot)

Sometimes while executing java programs my execution engine may require native method library that’s why we have “Native Method Libraries “ inside JRE. 
Who is responsible to provide “Native Method Libraries” information?
		Java Native Interface [ JNI ]
So Execution Engine will communicate with “JNI”
JNI will provide information about “Native Method Libraries” to Execution Engine.
 

11)	What is the job done by classloader ?
Ans:- classloader loads the java class. In java , classes are loaded on demand basis i.e. only when u use the class for the first time in ur application, class will be loaded.

12)	 Explain the hierarchy of  classloaders in java.
Ans:- There are 3 types of class loaders in java
a)	BootStrap Class Loader or Premordial Class Loader
b)	Extension Class Loader
c)	System Class Loader
BootStrap or Premordial class loader :-
	BootStrap class loader loads those classes which are essential for JVM to function properly. BootStrap class loader is responsible for loading all core java classes for instance  java.lang.* ,java.io.*  etc. BootStrap class loader finds these necessary classes from  “jdk/jre/lib/rt.jar” .
Extension class loader :-
	Extensions Classloader is the immediate child of Bootstrap classloader. This classloader loads the classes in lib\ext directory of the JRE.
System class loader :-
	System-Classpath classloader is the immediate child of Extensions classloader. It loads the classes and jars specified by the CLASSPATH environment variable, java.class.path system property, -cp or -classpath command line settings. If any of the jars specified in one of the above manner have a MANIFEST.MF file with a Class-Path attribute, the jars specified by the Class-Path attribute are also loaded. This class loader is also used to load an application’s entry point class that is the “static void main()” method in a class.

13)	What is the role played by Bytecode Verifier ?
Ans:- Bytecode Verifier performs verification of bytecodes. When a class loader presents the bytecodes of a newly loaded Java platform class to the virtual machine, these bytecodes are first inspected by a verifier. The verifier checks that the instructions cannot perform actions that are obviously damaging. All classes except for system classes are verified.

14)	What are the memory areas allocated by JVM ?
Ans:-
a) Class(Method) Area or metaspace(according to java8):
Class(Method) Area stores per-class structures such as the runtime constant pool, field and method data, the code for methods.
b) Heap:
It is the runtime data area in which objects are allocated.
c) Stack:
Java Stack stores frames. It holds local variables and partial results, and plays a part in method invocation and return.
Each thread has a private JVM stack, created at the same time as thread.
A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes.
d) Program Counter Register:
PC (program counter) register. It contains the address of the Java virtual machine instruction currently being executed.
e) Native Method Stack:
It contains all the native methods used in the application.



15)	What is the difference between  Java compiler ( javac ) and JIT ?
Ans:- javac converts source code into the bytecode whereas JIT converts bytecode into native code.
 


16)	Is JRE different for different Platforms ?
Ans:- yes

17)	Difference bet’n C++ and java in terms of object creation.
Ans:- in C++ object can be created on stack as well as on heap (because java has given importance to late binding from the very beginning)

18)	What is garbage collection ?
Ans:- Automatic garbage collection is the process of looking at heap memory, identifying which objects are in use and which are not, and deleting the unused objects. An in use object, or a referenced object, means that some part of your program still maintains a pointer to that object. An unused object, or unreferenced object, is no longer referenced by any part of your program. So the memory used by an unreferenced object can be reclaimed.

19)	Can we force garbage collection programmatically?
Ans:- no, we can at the most request for Garbage Collection using “System.gc()” or “Runtime.gc()”.
20) How to request JVM for garbage collection
Ans:- We now know that the unreachable and unusable objects are available for garbage collection but the garbage collection process doesn’t happen instantly. Which means once the objects are ready for garbage collection they must to have to wait for JVM to run the memory cleanup program that performs garbage collection. However you can request to JVM for garbage collection by calling System.gc() or Runtime.gc() method.

21)	How to use finalized method?
Ans:- Following example demonstrates exactly how we can use “finalized()” method.

public class MyClass
{   
	   public static void main(String args[])
	   {
		   
		   /* Here we are intentionally assigning a null 
	         * value to a reference so that the object becomes
	         * non reachable
	         */
		   MyClass obj=new MyClass();  
		obj=null;  
			
	        /* Here we are intentionally assigning reference a 
	         * to the another reference b to make the object referenced
	         * by b unusable.
	         */
		MyClass a = new MyClass();
		MyClass b = new MyClass();
		b = a;
		System.gc();  
	   }  
	   protected void finalize() throws Throwable
	   {
	        System.out.println("Garbage collection is performed by JVM");
	   }
}

In the above code we have overridden a finalize() method. This method is invoked just before a object is destroyed by java garbage collection process. This is the reason you would see in the output that this method has been invoked twice.

22)	What is an alternative for finalized method?
Ans:- It is not recommended to rely on finalized method because of its non-guaranteed behavior but then what is an alternative of releasing resource, performing cleanup because there is no destructor in Java?  Having a method like close() or destroy() make more sense for releasing resources held by classes. In fact JDK library follows this. E.g various inputstream and outputstream implementations are having “close()” method to release the resources.  In fact it’s one of the best practice to call close method from finally block in java. Only problem with this approach is its not automatic, client has to do the cleanup and if client forgets to do cleanup there are chances of resources getting leaked, which again suggests us that we could probably give another chance to finalize method.
23)	What is the difference between System.gc() and Runtime.getRuntime().gc() ?
Ans:- Both are same. System.gc() is effectively equivalent to Runtime.gc(). System.gc()internally calls Runtime.gc().
The only difference is System.gc() is a class method where as Runtime.gc() is an instance method. So, System.gc() is more convenient.
If you look at System class source code, it has got following method:
public static void gc() 
{
        Runtime.getRuntime().gc();
 }


24)	When do u get NullPointerException ?
Ans:- when reference variable containing null and if it’s used to invoke member, we get NullPointerException.
 
25)	What is the signature of main function in java ?
Ans:-   public static void main(String args[]) 					or												public static void main(String …args)

26)	Who invokes main() function ?
Ans:- JVM invokes main() function.

27)	Can we define more than one public class in a java source code ? what is the rule of public class and file name . ?
Ans:- no we can’t define more than one public class in one source file.  Name of the public class and the file name must match.

28)	Difference bet’n path and classpath.
Ans:- path is used for “.exe”,”.dll” and “.bat” files
	Classpath is used for “.jar” files.

29)	What is the rule for local member in java.
Ans:- local member must be initialized before use.

30)	What is  .class file known as ?
Ans:-  java bytecode

31)	How java is strong object oriented ?
Ans:- java does not allow global members, friend function. Everything (variables as well as methods) must be defined inside the class.

32)	What is finalized() method ?
Ans:-  finalize method in java is called before Garbage collector reclaim the Object. It’s last chance for any object to perform cleanup activity i.e. releasing any system resources held, closing connection if open etc. Main issue with finalized method in java is its not guaranteed by JLS that it will be called by Garbage collector or exactly when it will be called, for example an object may wait indefinitely after becoming eligible for garbage collection and before its finalize() method gets called. Because of this reason it make no sense to use finalized method for releasing critical resources  finalized. It may work in development in one JVM but may not work in other JVM.

33)	Why there is no sizeof operator in java ?
Ans:- because size  of all the java datatypes is identical across all platforms.

34)	What kinds of programs u can develop using Java?
There are mainly 5 types of applications that can be created using java:
a) Standalone Application
It is also known as desktop application or window-based application. An application that contain “main” function as an entry point.
b) Applet
 It is a java program which can run on java-enabled web browser
c) Web Application
An application that runs on the server side and creates dynamic page, is called web application. Currently, servlet, jsp, struts, jsf etc. technologies are used for creating web applications in java.
d) Enterprise Application
An application that is distributed in nature, such as banking applications etc. It has the advantage of high level security, load balancing and clustering. In java, EJB is used for creating enterprise applications.
e) Mobile Application
An application that is created for mobile devices. Currently Android and Java ME are used for creating mobile applications.

35)	Difference bet’n  C++ pointer and Java reference.
Ans:- similarity bet’n two is both of them store the address of heap based object. Difference is c++ pointer can be incremented, decremented and also can be dereferenced. None of these operations u can invoke on java reference variable.
36)	U have reference type as a member of class. What is the default value it gets?
Ans:- null

37)	What are the expressions allowed in switch block of java ?
Ans:- byte,short,int,char and String ( jdk 1.7 onwards)

38)	In a java source code there are 3 classes define  e.g  class A{} class B{} and class C{}. When u compile the source code how many .class files u get and what are their names ?
Ans:- A.class,  B.classs,  C.class

39)	What is java’s old name ?
Ans:- oak

40)	What are the technologies come under “Distributed Object System “ ?
Ans:-  RMI, CORBA and EJB

41)	What do u mean by Java Enabled Browser, Web Server and Application Server?
Ans:- Java-Enabled means having “JRE” inside it.

42)	What is “this”? What is its importance?
Ans:- “this” is a reference to the current object or invoking object. With the help of “this” reference member function comes to know about the invoking object. Actually when u invoke any member function, compiler implicitly passes the “this” reference to the method being invoked.

43)	What is UnsupportedClassVersion error ?
Ans:- when a upper-version class file is executed in the lower-version JVM, (e.g. javac belongs to 8 and JRE belongs to 1.7  )	
java.lang.UnsupportedClassVersionError occurs.

44)	What is Unicode Character Set in Java ?
Ans:- Since Java is designed to support Internationalization ( I18N ),it makes sense that it would use Unicode to represent characters. Unicode defines a fully international character set that can represent all of the characters found in all human languages. It is a unification of dozens of character sets such as Latin, Greek, Arabic and many more. For this purpose, it requires 16 bits. Thus char in java is 16 bit type. The range of char is 0 to 65535. There are no negative chars.

45)	Explain Java Execution Flow.
Ans:- Virtual Machine Start-Up

A Java virtual machine starts execution by invoking the method main of some specified class, passing it a single argument, which is an array of strings if provided else an empty array. 

For example:
java Test 

will typically start a Java virtual machine by invoking method main of class Test .

Load the Class Test

Link Test: Verify, Prepare, (Optionally) Resolve
Linking involves verification, preparation and (optionally) resolution. 

Verification checks that the loaded representation of Test is well-formed, with a proper symbol table. Verification also checks that the code that implements Test obeys the semantic requirements of the Java programming language and the Java virtual machine. If a problem is detected during verification, then an error is thrown. 

Preparation involves allocation of static storage and any data structures that are used internally by the virtual machine, such as method tables. 

Resolution – Eager Resolution if any.



Initialize Test: Execute Initializers
Initialization consists of execution of any class variable initializers and static initializers of the class Test, in textual order. But before Test can be initialized, its direct superclass must be initialized, as well as the direct superclass of its direct superclass, and so on, recursively. In the simplest case, Test has Object as its implicit direct superclass; if class Object has not yet been initialized, then it must be initialized before Test is initialized. Class Object has no superclass, so the recursion terminates here.
If class Test has another class Super as its superclass, then Super must be initialized before Test. This requires loading, verifying, and preparing Super if this has not already been done and, depending on the implementation, may also involve resolving the symbolic references from Super and so on, recursively.
Initialization may thus cause loading, linking, and initialization errors, including such errors involving other types.

Invoke Test.main
Finally, after completion of the initialization for class Test (during which other consequential loading, linking, and initializing may have occurred), the method main of Test is invoked.

The method main must be declared public, static, and void. It must accept a single argument that is an array of strings. This method can be declared as either public static void main(String[] args)
Or  public static void main(String... args)

Loading of Classes and Interfaces which are referenced from main() function………

 

46)	What is the difference bet’n Lazy and Eager Resolution?
Ans:- e.g. suppose Car class has Engine as a member.
Here if Car has Engine as static member, Engine will be resolved (loaded) as soon as Car is loaded ( Eager ). On the other hand if Car has Engine as non-static member, Engine will be resolved (loaded) only after you instantiate the Car (Lazy).

47)	Does Java have pass by reference or by value?
Ans:- Java passes everything by value, and not by reference. When we say everything, that means – Primitive types as well as reference types, these are all passed by value in Java. 
In case of reference types, what happens is you pass a reference to an object to a method. Inside method it is collected in another reference (formal argument) to that same object.
Now you can modify this formal argument inside the method as much as you want but no matter how hard you try you'll never be able to modify the passed reference that will keep referencing the same Object no matter what!

*****************************************************************************************************************************************************
1)	What is instanceof operator ? give an example:
Ans:- In Java, instanceof operator is used to check “is-a” relationship at runtime. 

example of instanceof operator

class FourWheeler
{
}
class Car extends FourWheeler
{
}
public class MyClass
{
	public static void main(String[] args)
	{
		FourWheeler f=new Car();
		System.out.println(f instanceof Car);   // true
		System.out.println(f instanceof FourWheeler); //true
		System.out.println(f instanceof Object); // true
	}
}


2)	 What is upcasting and downcasting with example?

UpCast -> making base class reference referring to sub class object or assigning sub class object to base class reference.
It is required to make polymorphic calls with an enormous flexibility.
e.g
					Weapon
						attack
Gun			Sword			Riffle
All these child classes have overridden “attack()” method.
We can make Weapon class reference and make it refer to any child class (existing or may be introduced later ) and invoke “attack()” method polymorphically. Here code which invokes “attack()” with the help of “Weapon” class remains unchanged irrespective of changes happen inside inheritance hierarchy [ i.e. any child class gets removed or added ].

Downcast -> converting base class reference to sub class reference.
It is used to invoke that method of sub class which is not a part of base class.
e.g. in case of above hierarchy suppose we have an additional method “fillBullets()” inside Gun. Now when Weapon reference refers to Gun, we would like to invoke “fillBullets()” along with “attack()”. For this reason we need to downcast from Weapon to Gun.

3)	 What is the risk involved in downcasting ? How instanceof operator provides solution for that?
Ans:-  void perform(Weapon ref)
		{
			Gun g=(Gun)ref;
			g.fillBullets();
			g.attack();
		}
	If someone calls “perform()” method by passing “Sword” instance, we will get “ClassCastException”. We can improve our code as follows:

		void perform(Weapon ref)
		{
			if(ref instanceof Gun)
			{
				Gun g=(Gun)ref;
				g.fillBullets();
			}
			ref.attack();
		}

In case of above code we downcast from Weapon to Gun only if ref refers to Gun. Thus “instanceof” saves us from getting “ClassCastException”.

4)	 Given, in C++, 
   MyClass m1;
MyClass m2=m1; 
And in Java,
MyClass m1=new MyClass();
MyClass m2=m1;

What is the difference?
Ans:- in C++ It means “m2” object is initialized with “m1”.  i.e. for “m2” copy constructor is called, which is provided by compiler implicitly.

In java It means that “m2” reference is initialized using “m1” reference, i.e. “m2” refers to the same object “m1” refers to.

5)	In Java copy constructor is not provided implicitly. Can we provide it explicitly and if yes when exactly it will be called?
Ans:- Yes we can provide copy constructor explicitly in java as follows:
Suppose class name is “MyClass” then the copy constructor would be:
MyClass(MyClass ref)
{
…… code for copy…
}

So if you say….
MyClass m1=new MyClass();
MyClass m2=new MyClass(m1);

Copy constructor would be invoked for second object.

6)	How many types of inheritance allowed in java ?
Three types of inheritance: single, multilevel and hierarchical.
 

7)	Why “Multiple Inheritance” is not supported in Java?
Ans:- Multiple inheritance permits you to derive a subclass from more than one direct superclass. This poses a problem if two direct parent classes have conflicting implementations from Grand Parent. Now which one to follow in the child class? i.e. a famous “Diamond Problem”!. This problem ideally can be solved by declaring a Grand Parent class as “virtual base” class, just to ensure that only one copy of Grand Parent in child class object. But these all add complications to the language and hence Multiple Inheritance is not allowed in java.

8)	Explain accessibility modifiers in java.

Accessibility modifiers	Same class 	Sub class in same package	Different class in same package	Sub class in different package	Different class in different package
Private	Yes	No	No	No	no
<default>	Yes	Yes	Yes	No	no
Protected	Yes	Yes	Yes	Yes	no
Public	Yes	Yes	Yes	Yes	yes


9)	What is super keyword?
Ans:- super keyword is used to access parent class member ( member functions as well as constructors)
10)	What is the rule for super keyword?
Ans:- when super keyword is used to invoke parent class constructor, it has to be on the first line of child class constructor.

11)	What is @Override? What does it do?
Ans:- @Override is an annotation which instructs compiler that we are overriding a particular method and then compiler will ensure that u follow all the rules while overriding especially method name, parameters are correct etc.


13)	What is Object class?
Ans:- Object class is the parent class of all the classes in java.

14)	What is “ClassCastException” ? What is the solution for that?
Ans:- when u try to cast the classes out of hierarchy, u get ClassCastException. 
Soloution:- before casting check the hierarchy with “instanceof” operator.


15)	Where can we apply final keyword in java ?
Ans:- final keyword can be applied to 
a) instance member
b) class variable
c) local variable
d) member function
e) class

final member must be initialized and once initialized it cannot be modified. It is also known as “compile-time constant”.
final member function cannot be overridden.
final class cannot be inherited.


16)	Can a class be defined a both final and abstract 
Ans:- No, because final and abstract are contradictory. i.e. abstract encourages inheritance whereas final stops inheritance.

17)	Explain “System.out.println”.
Ans:-  
class System
{
	public static PrintStream out;
	public static InputStream in;
}

class PrintStream
{
	public void print(){}
	public void println(){}
}  											

println()  is a non-static method of PrintStream class, hence it has to be invoked using the reference of PrintStream.  
out is a reference of PrintStream. i.e. out.println()
out is a public static member of System class . 
that’s why  “System.out.println()”
 
18)	Explain “public static void main”.
Ans:- 	public - so that main can be accessed from anywhere.

static - so that jvm need not create the object of class in which main function is defined.

void - main is not expected to return anything.

String args[] - in java main should be always ready to accept command line arguments.

19)	Can we use “this” with static member ?  
Ans:- No. “this” and “static” both are contradictory. i.e. this is a reference to invoking object and static is not at all related to object.

20) A constructor in Java is a special method that is used to initialize objects. The constructor is called when an object of a class is created. It can be used to set initial values for object attributes:

Note that the constructor name must match the class name, and it cannot have a return type (like void).

Also note that the constructor is called when the object is created.

All classes have constructors by default: if you do not create a class constructor yourself, Java creates one for you. However, then you are not able to set initial values for object attributes.



20)	Explain static block or static initializer.
Ans:- static block
	a) is used to access static members.
	b) is called as soon as class gets loaded.
	c) u can define more than one static block inside the class. They will get executed in the order in which they are defined.

17) Where have u seen an application of static block or initializer in java?
Ans:-  in JDBC. In JDBC all the drivers are java classes. Every jdbc driver class contain static initializer or static block. Inside this static block driver class tries to register itself with DriverManager. Advantage of this is that user does not need to explicitly invoke “registerDriver” method of DriverManager. He just has to ensure that driver class should be loaded and everything else happens automatically.

21)	What is non-static block?
Ans:- NON-STATIC BLOCK:is used for - if we have many constructor inside a class and those constructors need to have some common statements.
Instead of repeating those statements in each constructor, we place those statements in non-static block.

e.g counter which is incremented in each constructor , to keep a track of number of objects created.

22)	Can static member function access non-static data? 
Ans:- No. because static member function can be called without creating object. When object is not created, non-static member is not allocated memory.
23)	Can non-static member function access static data?
Ans:- Yes. Because in order to invoke non-static member function u need to create object and by that time static members are already allocated memory.

24)	Explain constructor invocation in case of inheritance.
Ans:- when u instantiate child class, child class constructor by default invokes “no-arg” constructor of parent class. If parent class does not have “no-arg” constructor, then child class must invoke one of the available constructors of parent class explicitly ( using “super”)

25)	In case of inheritance, if parent class does not have no-arg constructor, what happens? How do u solve the problem?
Ans:- in such case, when u try to instantiate child class u get compile-time error. 					Solution:- If parent class does not have “no-arg” constructor, then child class must invoke one of the available constructors of parent class explicitly ( using “super”)

26)	In case of an array which variable is created automatically? Can u modify it? If no, why?
Ans:- in java whenever u create array, u get “length” variable by default which is nothing but size of array. No u can’t modify it because it is final.

27)	What is class Class in java ?
Ans:- In java whenever any class gets loaded, it is represented by an instance of class Class.
All instances of a particular class share the same Class object and you can obtain the Class object by calling the getClass() method of the object. This method is inherited from java.lang.Object

Suppose you create two instances of class called Person e.g.

Person A = new Person();
Person B = new Person();

if(A.getClass() == B.getClass())
{
System.out.println("A and B are instances of same class");
}
Else
{
System.out.println("A and B are instances of different class");
}

In this case it will print "A and B are instances of same class" because they are both instance of class Person.

25) What is the use of class “Class” in java?
Ans:- The main use of class “Class” is in case of Reflection API , the technique to find out everything about a particular class during runtime.

26)	What  does “forName() “ function do ?
Ans:- it is used to load a particular class explicitly. It returns the Class object associated with the class or interface loaded.

27)	When does class get loaded?
Ans:- a) implicitly

			java MyClass

				or

			emp e=new emp(); when u create first 
object of that class

				or


			emp.staticmemberfun();

Whichever is first……..

	b) Explicitly

		Class.forName("classname");

28)	What is bridge method in java?
Ans:- When u override parent class method with a co-variant return type, compiler synthesizes (implicitly provides) additional method in child class with a matching signature of overridden method. This method invokes the method which we are overriding. This synthesized method is known as “Bridge Method”.
29)	Why compiler synthesizes bridge method in case of overriding?
Ans:- suppose we have overridden a parent class method with co-variant return type e.g.
class base
{
	public Object disp()
	{
		System.out.println("base disp");
		return null;
	}
}
class sub extends base
{
	public String disp()
	{
		System.out.println("sub disp");
		return null;
	}
}

Even though the above overriding is correct according to compiler, for JVM this is not exactly an overriding because their return types are different.
 To solve this problem, compiler adds a bridge method [public Object disp() ] in Derived class [ sub ] which calls the method which we have overridden.
27) What are the scenarios in which we have early binding in java?
Ans:- in case of private or static or final methods.
28)	What is .length variable in case of array? Can we see it using Reflection API technique?
Ans:- when u create any type of array internally .length variable gets created which stores the size of array. Its signature is “public final int length”
Arrays are not like regular classes, they are a special case defined in the Java Language Specification. So the .length public final variable is defined in the Java Language Specification, but it is not actually defined anywhere in a .java or a .class file. Hence we cannot see it using Reflection API technique.



**************************************************************************************************************************************
1)	Explain abstract class in Java.
Ans:- in java as soon as u define a class with "abstract" keyword, class becomes abstract.
abstract class cannot be instantiated.
abstract class can contain abstract as well as non-abstract methods.
abstract method is a method which is declared with "abstract" keyword.
a child class of an abstract class has to provide implementation to the method which is declared "abstract" in parent class or else make child class also "abstract".

2)	What is the need of abstract class?
Ans:- Abstract classes let you define some behaviors; they force your subclasses to provide others. For example, if you have an application framework, an abstract class may provide default services (concrete) such as event and message handling. Those services allow your application to plug in to your application framework. However, there is some application-specific functionality (abstract) that only your application can perform. Such functionality might include startup and shutdown tasks, which are often application-dependent. So instead of trying to define that behavior itself, the abstract base class can declare abstract shutdown and startup methods. The base class knows that it needs those methods, but an abstract class lets your class admit that it doesn't know how to perform those actions; it only knows that it must initiate the actions. When it is time to start up, the abstract class can call the startup method. When the base class calls this method, Java calls the method defined by the child class.

3)	Explain interface in Java8
Ans:- interfaces are abstract in nature. i.e. they can not be instantiated.

interface can contain 
	members
	abstract methods
	default methods
	static methods

members declared in interface are by default "public","static" and "final".

methods declared ( and not defined) inside interface are by default "public" and "abstract".

a class can be derived from more than one interfaces.  (implements keyword is used here )

child class of an interface has to provide implementation of the method/s which are declared abstract in parent or else child class also has to be declared as "abstract".

default method/s (which are by default "public") may or may not be overridden by child class. ( if overridden, "public" modifier is compulsory)

static methods are like utility methods which can be invoked only on the interface in which they are defined.


4)	Why do we need interface?
Ans:- Interfaces are important because they separate what a class does from how it does it. The contract defining what a client can expect leaves the developer free to implement it any way they choose, as long as they uphold the contract.
You see examples of this all over the JDK. Look at the java.sql package - it's riddled with interfaces. Why? So different relational databases can be free to implement those methods for their particular product. Clients need only deal with the interface reference types. Changing relational databases is as easy as swapping one JDBC driver JAR for another. Clients need not change. (As long as they don't stray from the contract.)
You can program to an interface instead of a concrete implementation in order to make your code flexible.
In addition to this, interfaces make unrelated classes relate e.g.

class Aeroplane extends Vehicle{}
class SuperMan extends Person{}
class Bird extends Animal{}
	Though these classes are unique, there exists one common factor “fly()”
So we can relate these unrelated classes with the interface “Flyable”
	interface Flyable
	{
		void fly();
	}

class AeroPlane extends Vehicle implements Flyable{public void fly(){ fly like AeroPlane}}
class SuperMan extends Person implements Flyable{public void fly(){ fly like SuperMan}}
class Bird extends Animal implements Flyable{public void fly(){ fly like Bird}}

And now somewhere we can have code :
	void perform(Flyable ref)
	{
		ref.fly();
	}
And we can pass :
	perform(new AeroPlane());
	perform(new SuperMan());
	perform(new Bird());


5)	 Using interface reference we can invoke only those methods which are present in it.
Given:

interface myinterface
{
	void disp();
}
public class MyClass
{
	public static void main(String[] args)
	{
		myinterface m1,m2=null;
		m1.disp();
		m1.fun();
		m1.toString();
		m1.equals(m2);
		m1.hashCode();
	}
}

Which of the above invocations are illegal at compile-time?
Ans:- only “m1.fun();” is illegal, rest all are legal at compile-time. It is true that using interface reference we can invoke only those methods which are present in it. But “toString()” ,”equals()” and “hashCode()” invocations are legal because these methods are available inside “java.lang.Object” which is the base class of all the classes in java. Now compiler understands that any implementation of given interface is by default sub class of “java.lang.Object”, hence compiler allows you to invoke above mentioned methods using interface reference.

6)	When to use interface and when to use abstract class? Explain with example.

Interface is used when you want to define a contract and you don't know anything about implementation. (here it is total abstraction as you don't know anything.)

Abstract class is used when you know something and rely on others for what you don't know.(here it is partial abstraction as some of the things you know and some you don't know.)

When to use Interface
Scenario, 
Consider we want to start a service like "makemytrip.com" or "expedia.com", where we are responsible for displaying the flights from various flight service company and place an order from customer. 
Let’s keep our service as simple as, 

1.	Displaying flights available from vendors like "airasia", "british airways" and "emirates".
2.	Place and order for seat to respective vendor.

How should we design our application considering interfaces and abstract class? In this scenario, interface is useful or abstract class?

Remember, In this application, we don't own any flight. we are just a middle man/aggregator and our task is to first enquire "airasia", then enquire "british airways" and at last enquire "emirates" about the list of flights available and later if customer opts for booking then inform the respective flight vendor to do booking.


For this, first we need to tell "airasia", "british airways" and "emirates" to give us list of flights, internally how they are giving the list that we don't care.

1.	This means I only care for method "getAllAvailableFlights()"

"getAllAvailableFlights()" from "airasia" may have used SOAP service to return list of flights.
"getAllAvailableFlights()" from "british airways" may have used REST service to return list of flights.
"getAllAvailableFlights()" from "emirates" may have used CORBA service to return list of flights.

but we don't care how it is internally implemented and what we care is the contract method "getAllAvailableFlights" that all the flight vendor should provide and return list of flights.

2.	Similarly, for booking I only care for method "booking()" that all vendors should have, internally how this vendors are doing booking that I don't care.

To conclude: We know contract. 
So we can say that we know the contract that irrespective of who the Flight vendor is, we need "getAllAvailableFlights()" and "booking()" method from them to run our aggregator service.

In this situation, Interface is useful because we are not aware of the implementation of all the 2 methods required, and what we know is the contract methods that vendor(implementer) should provide. so due to this total abstraction and for defining the contract, interface is useful in this place.
Technically, we need to design our interface somewhat like below,

FlightOpeartions.java(Contract) 
?
1
2
3
4	interface FlightOpeartions{
 void getAllAvailableFlights();
 void booking(BookingObject bookingObj);
}
BookingObject.java 
?
1	class BookingObject{}
BritishAirways.java (Vendor 1) 
?
1
2
3
4
5
6
7
8
9
10
11
12
13	class BritishAirways implements FlightOpeartions{
 
 public void getAllAvailableFlights(){
           //get british airways flights in the way 
           //they told us to fetch flight details.
 }
 
 public void booking(BookingObject flightDetails){  
          //place booking order in a way British airways 
          //told us to place order for seat.
 }
 
}
Emirates.java (Vendor 2) 
?
1
2
3
4
5
6
7
8
9
10
11
12	class Emirates implements FlightOpeartions{
 
 public void getAllAvailableFlights(){
         //get Emirates flights in the way 
         //they told us to fetch flight details.
 }
 
 public void booking(BookingObject flightDetails){  
         //place booking order in a way Emirates airways
         //told us to place order for seat.
 }
}


When to use Abstract class
Scenario, 
Consider we want to start a service like Bulk SMS sender, where we take orders from various telecom vendors like Airtel, France Telecom, Vodafone etc.

For this, we don't have to setup our own infrastructure for sending SMS like Mobile towers but we need to take care of government rules like after 9PM, we should not send promotional SMS, we should also not send SMS to users registered under Do Not Disturb(DND) service etc. Remember, we need to take care of government rules for all the countries where we are sending SMS.

Note: for infrastructure like towers, we will be relying on vendor who is going to give us order.
Example, In case of,
Vodafone request us for bulk messaging, in that case we will use Vodafone towers to send SMS. 
Airtel request us for bulk messaging, in that case we will use Airtel towers to send SMS.
What our job is to manage Telecom Regulations for different countries where we are sending SMS. 
  
So what all methods we require would be somewhat like below,
?
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26	public void eastablishConnectionWithYourTower(){
   //connect using vendor way.
   //we don't know how, candidate for abstract method 
}
 
public void sendSMS(){
   eastablishConnectionWithYourTower();
   checkForDND();
   checkForTelecomRules();  
   //sending SMS to numbers...numbers.
   destroyConnectionWithYourTower()
}
 
public void destroyConnectionWithYourTower(){
   //disconnect using vendor way. 
   //we don't know how, candidate for abstract method
}
 
public void checkForDND(){
   //check for number present in DND.
}
 
public void checkForTelecomRules(){
   //Check for telecom rules.
}

Out of above 5 methods, 
1.	Methods we know is "sendSMS()", "checkForDND()", "checkForTelecomRules()".
2.	Methods we don't know is "eastablishConnectionWithYourTower()", "destroyConnectionWithYourTower()".
we know how to check government rules for sending SMS as that is what our job is but
we don't how to eastablish connection with tower and how to destroy connection with tower because this is purely customer specific, airtel has its own way, vodafone has its own way etc. 

So in the given scenario, we know some methods but there also exist some methods which are unknown and depends on customers.

In this case, what will be helpful, abstarct class or interface?

In this case, Abstract class will be helpful, because you know partial things like "checkForDND()", "checkForTelecomRules()" for sending sms to users but we don't know how to eastablishConnectionWithTower() and destroyConnectionWithTower() and need to depend on vendor specific way to connect and destroy connection from their towers.
Let's see how our class will look like,
?
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50	abstract class SMSSender{
  
 abstract public void eastablishConnectionWithYourTower();
  
 public void sendSMS(){
  /*eastablishConnectionWithYourTower();
  checkForDND();
  checkForTelecomRules();  
   
  sending SMS to numbers...numbers.*/
 }
 
 abstract public void destroyConnectionWithYourTower();
 
 public void checkForDND(){
  //check for number present in DND.
 }
 public void checkForTelecomRules(){
  //Check for telecom rules
 }
}
 
 
class Vodafone extends SMSSender{
 
 @Override
 public void eastablishConnectionWithYourTower() {
  //connecting using Vodafone way
 }
 
 @Override
 public void destroyConnectionWithYourTower() {
  //destroying connection using Vodafone way
 }
  
}
 
class Airtel extends SMSSender{
 
 @Override
 public void eastablishConnectionWithYourTower() {
  //connecting using Airtel way
 }
 
 @Override
 public void destroyConnectionWithYourTower() {
  //destroying connection using Airtel way
 }
  
}


So to summarize, 
For Interface:
Interface is used when you don't know anything about implementation but know the contract that implementer should have to accomplish the task.
For Abstract class:
Abstract class is used when you know partial implementation, where say out of 5 methods, you know implementation of 3 methods and don't know implementation of 2 methods in that case 2 methods will be abstract and you need to rely on implementer as a contract to must provide body of abstract methods to accomplish the task.
7)	How many ways we can achieve Polymorphism in Java?
Ans:-
Polymorphism using class
Class Animal
{
	Int legs;
	Virtual Void makeSound()
	{
		Cout<<”Groul”;
	}
}

Class Cat extends Animal
{
	Void makeSound()
	{
		Cout<<”meow…”;
	}
}

Animal a=new Cat();
a.makeSound();

Polymorphism using interface.
e.g.  how to relate unrelated classes
we have 3 objects from unrelated classes.

Vehicle					IFlying     - interface
Plane						fly()  - method

Superhero
Superman

Animal
Bird


IFlying f=list.nextObj();

Here list contains all “Plane” or “Bird” or “Superhero”  objects.

f.fly();    // late binding

this is polymorphism without using base class. i.e. using base interface.
So , with the help of “IFlying” interface, we have related all unrelated classes.
U can implement Polymorphism  through Common Interface among unrelated classes.

Apply interface when u don’t have common base class.
Apply base class when u have related classes.




8)	 What is the difference between abstract class and interface in Java8?
Ans:- Abstract class can define constructor. They can have a state (instance members) associated with them.
Interfaces still can't have any state. Interfaces still can't have any final method, which means that any implementation can override all its default methods. And interfaces still can't have any constructor.
You can still implement multiple interfaces, even if they have default methods with the same signature. You can't extend multiple classes (abstract or not).
1.	a class may inherit from only one other class, but can implement many interfaces.
2.	an interface may not have any fields, except defining constants, while an abstract class can.
3.	an abstract class may define a constructor, while an interface cannot.
Default methods are restricted to input parameters and method calls. They are stateless in nature. An abstract class may have state. Hence, from the perspective of design, we should use abstract classes whenever you need code reuse. 
Interfaces are perfect to follow the principle “Program to interface and not implementation”.
9)	What are the default methods in Java8 interfaces Ans:- Java 8 introduces “Default Method” or (Defender methods)  or virtual extension methods new feature, which allows developer to add new methods to the interfaces without breaking the existing implementation of these interface. It provides flexibility to allow interface define implementation which will use as default in the situation where a concrete class fails to provide an implementation for that method.
So now existing interfaces can be enhanced without compromising backward compatibility by adding extension methods to the interface, whose declaration would contain instructions for finding the default implementation in the event that implementers do not provide a method body. A key characteristic of extension methods is that they are virtual methods just like other interface methods, but provide a default implementation in the event that the implementing class does not provide a method body.
10)	 What is the actual use of “default” method in interface?
Ans:- if we want to add additional methods in the interfaces, it will require change in all the implementing classes. As interface grows old, the number of classes implementing it might grow to an extent that it’s not possible to extend interfaces. That’s why when designing an application, most of the frameworks provide a base implementation class and then we extend it and override methods that are applicable for our application. 
 E.g. List is a parent interface for AbstractList abstract class which is a parent for ArrayList,LinkedList etc.
interfaces are too tightly coupled with their implementation classes. i.e. it is not possible to add a method in interface without breaking the implementer class. Once you add a method in interface, all its implemented classes must declare method body of this new method.
Java 8 introduces “Default Method” or (Defender methods)  or virtual extension methods new feature, which allows developer to add new methods to the interfaces without breaking the existing implementation of these interface. It provides flexibility to allow interface define implementation which will use as default in the situation where a concrete class fails to provide an implementation for that method.
11)	What do u mean by “Class wins” rule in java8?
Ans:- e.g. class C extends A implements B
Now class A has a concrete method “void disp()” and interface B has a default method “void disp()”. In this case C will inherit the method from class A and default method from interface B will be simply be ignored. This is the “Class wins” rule in java8. The “Class wins” rule ensures compatibility with Java7.
12)	Why it is not recommended to make a default method that redefines one of the methods from Object class?
Ans:- as a consequences of the “Class wins” rule such method could never win against Object.toString() or Object.equals().
 
13)	Why do we need static methods in interface?
Ans:- static methods are the utility methods. Before Java8,it has been common to place static methods in companion classes.
You find pairs of interfaces and utility classes such as Collection/Collections or Path/Paths in the standard library. With the introduction of static methods now we don’t require such utility classes.


14)	 Explain this vs super in case of constructor invocation.
Ans:- this is used to invoke the constructors of same class ( constructor chaining ) whereas super is used to invoke parent class constructor.

15)	What is equals and hashcode contract?
Ans:- a) Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.

b) If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.

c) It’s not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hashtables.

16)	What is the difference between == and equals() method ?
Ans:- by default both of these are same i.e. both of them check whether two references are referring to same instance or not. If yes result is true otherwise false. This is because in Object class equals() method internally uses == operator only. However, we can always override equals() method of Object class to check the content.

17)	Explain  toString, equals and hashCode methods of Object class
Ans:-  public String toString()
	returns the String representation of an instance.

public boolean equals(Object)
	checks the equality of two references. If they are referring to same instance then they are equal otherwise not.

public int hashCode()
	every object is given a unique number inside memory. This number is called as hashcode. This method returns the hashcode of caller object.

18)	What do u mean by immutable class?
Ans:- when u perform any operation on any instance, it will not affect the same one, rather it will create a new one with modifications.
 
19)	How to create immutable class in java?
Ans:- in order to create immutable class , we need to follow some guidelines:
a) Don't provide "setter" methods — methods that modify fields 
b) If the instance fields include references to mutable objects, don't allow those objects to be changed: 
i.e. don’t provide methods that modify the mutable objects.
c) If the instance fields include references to mutable objects, don't allow those objects to be changed:
 Don't share references to the mutable objects.
d) If necessary, create copies to avoid returning the originals in your methods
e) A class should be final

20)	What are wrapper classes? What is their main application?
Ans:- Wrapper classes are used to convert any primitive type into an object. The primitive data types are not objects, they do not belong to any class, they are defined in the language itself. While storing in data structures which support only objects, it is required to convert the primitive type to object first, so we go for wrapper class.
21)	JDK 1.5 onwards, we can pass primitives (i.e. int,char,float etc.)  Directly to the method accepting “java.lang.Object”. Does it mean that there is no use of Wrapper classes now?
Ans:- No we can’t say that. It is true that JDK 1.5 onwards, we can pass primitives (i.e. int,char,float etc.)  Directly to the method accepting “java.lang.Object”. But what actually happens internally is, primitives are converted to Wrapper (autoboxing) and then Wrapper being a subclass of “java.lang.Object” can be passed to the method accepting “java.lang.Object”. (widening)

22)	Difference bet’n  StringBuilder and StringBuffer 
Ans:- StringBuilder is not thread-safe whereas StringBuffer is thread-safe (all of its methods are synchronized)

23)	What is autoboxing  and unboxing ?
Ans:- The automatic conversion of primitive data types into its equivalent Wrapper type is known as boxing and opposite operation is known as unboxing.

24)	Autoboxing and unboxing are limited to compiler only . What do u mean by this ? 
Ans:- all the autoboxing and unboxing instructions u write in your source code are removed by compiler while compiling the code. JVM does not understand "autoboxing" and "unboxing".Hence compiler removes them while compiling the source code.

25)	What technique is used to make variable number of arguments possible in java?
Ans:- compiler automatically convert variable number of argument to array.

26)	When u try to print any reference variable in java, u get some meaningful output. What do u mean by this?
Ans:- it means that the class must have overridden “toString()” method.

27)	Why can’t we instantiate abstract class?
Ans:- An Abstract class represents an abstract concept. Take an example of vehicle class. You cannot build a vehicle that is not something more specific.
An abstract class is not complete! The author marked it abstract to tell you that some implementation is missing in the code. The author has done some of the work, but you must fill in some bits yourself to get it working. The abstract keyword ensures that no one would accidentally initiate this incomplete class.

28)	Can abstract class have constructors in Java?
Ans:- Yes, abstract class can have constructor/s in Java. Since you cannot create instance of abstract class, constructor can only be called during constructor chaining, i.e. when you create instance of concrete implementation class. Now question arises what is the purpose of constructor, if you cannot instantiate abstract class? Well, it can still be used to initialize instance members, which are declared inside abstract class, and used by various implementations. Also even if you don’t provide any constructor, compiler will add default no argument constructor in abstract class, without that your subclass will not compile, since first statement in any constructor implicitly calls super(), default super class constructor in Java.

23) Can abstract class implement interface in Java? Do they require to implement all methods?

ans:- Yes, abstract classes can implement interface by using implements keyword. Since they are abstract, they don’t need to implement all methods. It’s good practice to provide an abstract base class, along with an interface to declare Type. One example of this is java.util.List interface and corresponding java.util.AbstractList abstract class. Since AbstractList implements all common methods, concrete implementations like LinkedList and ArrayList are free from burden of implementing all methods, had they implemented List interface directly. It’s best of both world, you can get advantage of interface for declaring type, and flexibility of abstract class to implement common behavior at one place.  
24) Can abstract class be final in Java?
Ans:- No, abstract class cannot be final in Java. Making them final will stop abstract class from being extended, which is the only way to use abstract class. They are also opposite of each other, abstract keyword enforces to extend a class, for using it, on the other hand, final keyword prevents a class from being extended. In real world also, abstract signifies incompleteness, while final is used to demonstrate completeness. Bottom line is, you cannot make your class abstract and final in Java, at same time, it’s a compile time error.

25) Can abstract class have static methods in Java?
Ans:- Yes, abstract class can have static methods.

26) Is it necessary for abstract class to have abstract method?
ans:- No, It’s not mandatory for an abstract class to have any abstract method. You can make a class abstract in Java, by just using abstract keyword in class declaration. Compiler will enforce all structural restriction, applied to abstract class, e.g. not allowing to create any instance. By the way, it’s debatable whether you should have abstract method inside abstract class or interface. 
27) Can abstract class contain main method in Java?

ans:- Yes, abstract class can contain main method, it just another static method and you can execute Abstract class with main method, until you don’t create any instance.

29) What do you mean by concrete class?
Ans:- a class which is not an abstract class i.e. a class which is a complete class ,which can be instantiated is known as “concrete class”.

30) What do you mean by “Functional Interface”?
Ans:- “Functional Interface” is the one having only one abstract method also known as “SAM (Single Abstract Method). It may have default or static methods.







5)	What happens when an exception is raised in a program?
Ans:- When an exception occurs within a method, the method creates an object and hands it off to the runtime system. The object, called an exception object, contains information about the error, including its type and the state of the program when the error occurred. Creating an exception object and handing it to the runtime system is called throwing an exception.
After a method throws an exception, the runtime system attempts to find something to handle it. The set of possible "somethings" to handle the exception is the ordered list of methods that had been called to get to the method where the error occurred. The list of methods is known as the call stack .
 

		The call stack
The runtime system searches the call stack for a method that contains a block of code that can handle the exception. This block of code is called an exception handler. The search begins with the method in which the error occurred and proceeds through the call stack in the reverse order in which the methods were called. When an appropriate handler is found, the runtime system passes the exception to the handler. An exception handler is considered appropriate if the type of the exception object thrown matches the type that can be handled by the handler.
The exception handler chosen is said to catch the exception. If the runtime system exhaustively searches all the methods on the call stack without finding an appropriate exception handler, the program execution aborts.

6)	Why do u handle the exception ?
Ans:-  exception handling ensures normal program execution even after exception gets raised.
7)	How to handle the exception ?
Ans:- using try….catch block
8)	When u write one try and multiple catch, what care u should take?
Ans:- The most specific catch block should precede the most generic catch block.
9)	What is “handle or declare” rule?
Ans:- a) whenever any method raises checked exception/s , method has to either handle [try….catch] or declare [throws] that checked exception/s.
b) whenever u invoke a method which has declared [using throws] checked exception/s , caller method has to either handle [try….catch] or declare [throws] that checked exception/s.


10)	 Can we write catch block in a following manner:
catch(Object ref)
{
}
Ans:-  No we cannot write catch block that way. Only “Throwable” class or one of its child classes can be the argument type in a catch clause. It is because, if the catch block is allowed to write in this way, we can use “throw new String()” or “throw new Thread()”  etc.
All the above mentioned combinations are illegal because Objects that are instances of “Throwable” class (or one of its child classes) only are thrown by the JVM or can be thrown by the Java throw statement. 
11)	What is finally block? Why do we need it?
Ans:- finally block is the one which gets executed irrespective of whether exception is raised or not. Since it is guaranteed to be invoked unlike finalized() method, we can release the resources such as file, database connection, sockets etc. inside it.
5) in which scenarios finally block will not get executed?
Ans:-  System.exit(0)  in try or catch    and  any unhandled exception is raised inside finally block.

6)	Define checked and unchecked exception.
Ans :
•	Checked exceptions:  Checked exceptions are those exceptions which can be raised in a correct program. Client code has to either handle the checked exceptions or declare them with the throws clause.
•	Unchecked exceptions: Unchecked exceptions are those exceptions which can be raised due to programming mistakes. Unchecked exceptions derived from RuntimeException. Exceptions that inherit from RuntimeException get special treatment. There is no requirement for the client code to deal with them.
7)	In java, adjectives ending in -able are interfaces Serializable, Comparable , Cloneable etc... So why is Throwable a class and not an interface?
Ans:- it is because they wanted to have some state associated with every exception that gets thrown such as message, cause, and stack trace etc. and you can't do that with interfaces.
8)	When will you create a checked exception?
Ans:- when you realize that client code will take some useful recovery action based on information in exception
You can go for checked exception.

9)	How do u create checked and unchecked exception?
Ans:- we create checked exceptions by deriving from “Exception” class whereas we create unchecked exceptions by deriving from “RuntimeException” class.

10)	Compiler enforces u to deal with checked exception.  What do u mean by this?
Ans:- u must either handle ( using  try… catch) or declare (using throws)

11)	Difference bet’n throw and throws.
Ans:- throw is used to raise the exception whereas throws is used to declare the exception.

12)	What is ARM block?
Ans:- ARM (Automatic Resource Management) block is also known as “try with resource” block.
e..g    try(FileInputStream fis=new FileInputStream())
		{
			Some statements….
		}
		catch(FileNotFoundException fe)
		{
			fe.printStackTrace();
		}
The try-with-resources statement is a try statement that declares one or more resources. A resource is an object that must be closed after the program is finished with it. The try-with-resources statement ensures that each resource is closed at the end of the statement. Any object that implements  java.io.Closeable, can be used as a resource.

13)	Is it recommended to handle “NullPointerException”,”ClassCastException” etc. using java code?
Ans:- No not at all. Exceptions are costly, and can slow down your code. Don’t just throw and catch exceptions, if you can use if..else expression to indicate result of operation, e.g. NullPointerException, ClassCastException etc. which may result in cleaner code and performance solution.
14)	What is Re-throwing an exception in java?
Ans:- Exceptions raised in the try block are handled in the catch block. If it is unable to handle that exception, it can re-throw that exception using throw keyword. It is called re-throwing an exception.

try
{
    String s = null;
    System.out.println(s.length());   //This statement throws NullPointerException
}
catch(NullPointerException ex)
{
    System.out.println("NullPointerException is caught here");
  
    throw ex;     //Re-throwing NullPointerException
}
15)	What are the legal combinations of try, catch and finally blocks?
Ans:- 
A)
try
{
    //try block
}
catch(Exception ex)
{
    //catch block
}

B)

try
{
    //try block
}
finally
{
    //finally block
}

C)

try
{
    //try block
}
catch(Exception ex)
{
    //catch block
}
finally
{
    //finally block
}

16)	What are some of the best practices of Exception Handling?
Ans:-
a. When deciding on checked exceptions vs. unchecked exceptions, ask yourself, "What action can the client code take when the exception occurs?"
If the client can take some alternate action to recover from the exception, make it a checked exception. If the client cannot do anything useful, then make the exception unchecked. By useful, it means, taking steps to recover from the exception and not just logging the exception. To summarize:
Client's reaction when exception happens	Exception type
Client code cannot do anything	Make it an unchecked exception
Client code will take some useful recovery action based on information in exception	Make it a checked exception
Moreover, prefer unchecked exceptions for all programming errors(logical errors): unchecked exceptions have the benefit of not forcing the client API to explicitly deal with them. They propagate to where you want to catch them, or they go all the way out and get reported. The Java API has many unchecked exceptions, such as NullPointerException, IllegalArgumentException, andIllegalStateException.
b. Preserve encapsulation.
Never let implementation-specific checked exceptions rise to the higher layers. For example, do not propagate SQLException from data access code to the business objects layer. Business objects layer do not need to know about SQLException. You have two options:
•	Convert SQLException into another checked exception, if the client code is expected to recover from the exception.
•	Convert SQLException into an unchecked exception, if the client code cannot do anything about it.
Most of the time, client code cannot do anything about SQLExceptions. Do not hesitate to convert them into unchecked exceptions. Consider the following piece of code:
public void dataAccessCode(){
    try{
        ..some code that throws SQLException
    }catch(SQLException ex){
        ex.printStacktrace();
    }
}
This catch block just suppresses the exception and does nothing. The justification is that there is nothing my client could do about an SQLException. How about dealing with it in the following manner?
public void dataAccessCode(){
    try{
        ..some code that throws SQLException
    }catch(SQLException ex){
        throw new RuntimeException(ex);
    }
}
This converts SQLException to RuntimeException. If SQLException occurs, the catch clause throws a new RuntimeException. The execution thread is suspended and the exception gets reported. Here we are not corrupting our business object layer with unnecessary exception handling, especially since it cannot do anything about an SQLException. If our catch needs the root exception cause, we can make use of the getCause() method available in all exception classes as of JDK1.4.

c) Close or release resource in finally block
This is a well-known best practice in Java and quite a standard, while dealing with networking and IO classes. Closing resources in finally block guarantees that precious and scarce resource released properly in case of normal and aborted execution, guaranteed by finally block. From Java 7, language has a more interesting automatic resource management or ARM blocks, which can do this for you. Nevertheless, always remember to close resources in finally block, which is important to release limited resources like FileDescriptors, used in case of both socket and files.

d) Including cause of Exception in stack-trace
Many times Java library and open source code wraps one Exception into another, when one exception is thrown due to result of another exception. Its become extremely important to log or print cause of root exception. Java Exception class provides getCause() method to retrieve cause which can be used to provide more information about root cause of Exception. This Java best practice helps a lot while debugging or troubleshooting an issue. 

e) Always provide meaningful message on Exception
message of Exception is the most important place, where you can point out cause of problem because this is the first place every programmer looks upon. Always try to provide precise and factual information here. For example, compare these two Exception messages for IllegalArgumentException :

message 1: "Incorrect argument for method"
message 2: "Illegal value for ${argument}: ${value}

first one just says that argument is illegal or incorrect, but second one include both name of argument and its illegal value which is important to point out cause of error. Always follow this Java best practice, when writing code for handling exceptions and errors in Java.


f) Converting Checked Exception into RuntimeException
This is one of the technique used to limit use of checked Exception in many of frameworks like Spring ,where most of checked Exception, which are raised from JDBC is wrapped into DataAccessException, an unchecked Exception. This Java best practice provides benefits, in terms of restricting specific exception into specific modules, like SQLException into DAO layer and throwing meaningful RuntimeException to client layer.


g) Remember Exceptions are costly in terms of performance
One thing which is worth remembering is that Exceptions are costly, and can slow down your code. Don’t just throw and catch exceptions, if you can use boolean expression to indicate result of operation, e.g. NullPointerException, ClassCastException etc. which may result in cleaner and performance solution. 

h) Avoid empty catch blocks
Nothing is worse than empty catch block, because it not just hides the Errors and Exception, but also may leave your object in unusable or corrupt state. Empty catch block only make sense, if you absolutely sure that Exception is not going to affect object state on any ways, but still it’s better to log any error comes during program execution. This is not a Java best practice, but a most common practice, while writing Exception handling code in Java.


i) Use Standard Exceptions
Our ninth Java best practice 
advice on using standard and inbuilt Java Exceptions. Using standard Exception instead of creating own Exception every now and then is much better in terms of maintenance and consistency. Reusing standard exception makes code more readable, because most of  Java developers are familiar with standard RuntimeException from JDK like, IllegalStateException, IllegalArgumentException etc. and they will immediately be able to know purpose of Exception, instead of looking out another place on code or docs to find out purpose of user defined Exceptions.

j) Document Exception thrown by any method
Java provides throw and throws keyword to throw exception and in javadoc you have @throw to document possible Exception thrown by any method. This becomes increasingly important if you are writing API or public interface. With proper documentation of Exception thrown by any method you can potentially alert anyone who is using it.

Q. 14) what is the difference between NoClassDefFoundError and ClassNotFoundException?

Ans:-
 
15) What are the performance implications about exception handling?
Ans:- Exceptions come with a price, and in order to understand some of the issues involved, let's look at the mechanism for handling exceptions. The Java Virtual Machine maintains a method-invocation stack (or call stack) that features a list of the methods that have been invoked by a thread, starting with the first method the thread invoked and ending with the current method. A method-invocation stack illustrates the path of method invocations a thread made to arrive at the current method. 
 
Figure 1. The Java method-invocation stack shows frames for the methods invoked.

Figure 1 shows a graphical representation of the method-invocation stack for our code. Inside the Java Virtual Machine, methods keep their state within the Java stack. Each method obtains a stack frame, which pushes onto the stack when the method invokes and pops from the stack when the method completes. (The stack frame stores the method's local variables, parameters, return value, and other key information needed by the Java VM). As methods continue to complete normally, their frames pop and the stack frame below turns into the currently executed method. 
So, for the purposes of our comparison, what needs to happen in Case 1? If a NoPassengerFoundException throws while executing the searchPassengerFlightRecord() method (the top stack frame), further execution of code halts and the Java VM receives control to implement Java's exception-handling mechanism. The Java VM then searches in the current method for a catch clause having NoPassengerFoundException. If it doesn't find such a clause, then the Java VM pops the stack frame for the current method, and the calling method becomes the current method. The Java VM again searches in the current method -- for a suitable catch clause. If the Java VM still doesn't find a suitable catch clause, it pops the current stack frame and then searches the next stack frame for a suitable catch clause, and so on, until it finally finds an appropriate one. Or, if it doesn’t find, then the application terminates with the stack trace printing on the console. Abrupt method completion is significantly more expensive (performance-wise) than a normal method completion.

18)	 How do you convert checked exception to unchecked exception?
Ans:-
Your code:

try
{
	Some statements
	…………
}
catch(CheckedException ce)
{
	throw new UncheckedException();
}

Now your caller need not handle or declare exception because you have converted checked exception to unchecked exception.

1)	What is process?
Ans:- process is a program in execution.
2)	What is thread?
Ans:- thread is one of the execution path within a process.
3)	Process-based multitasking , Thread-based multitasking  meaning and  examples
Ans:- process-based multitasking:- more than one processes are running simultaneously.  e.g.  word and excel applications are running simultaneously.

thread-based multitasking :- more than one threads are running simultaneously. e.g. within a word application, you can start formatting as well as printing.

4)	What  do u mean by context switching ?
Ans:- it means CPU jumps  from one task to another and vice-versa.

5)	Process-based multitasking   vs   Thread-based multitasking.
Ans:- a) threads can share the memory, processes can not.
b) context switching between threads is relatively cheaper as compare to that between processes.
c) cost of communication bet'n threads is also low.

( cheaper or cost is low  actually means less no. of system resources are used.)

6)	What is one of the main application of multi-threading in java ? Explain.
Ans:-  multithreading can be used to create an effective server side application so that it can receive multiple client at a time ( each client will be processed by new thread ). e.g. Servlet, JSP

7)	What are the main steps in a typical multithreading application?
Ans:- a) create thread/s
b) define thread execution body
c) register thread with the thread schedular
d) thread schedular will execute the thread/s


8)	Can we directly call run() method ? what happens in that case ?
Ans:- yes , we can call run() directly. But in that case it won't be thread  execution, it is a normal method call. That is different call stack won't be created.

9)	What is the default priority every user thread gets?
Ans:- normal priority

10)	Explain “extends Thread”.
Ans:-   a) define a class say e.g.  MyThread extends Thread
b) override “public void run()” to define thread execution body.
c) create required number of “MyThread” instances.
d) invoke “start()” method on the above created instances.

11)	Explain “implements Runnable”.
Ans:-  a) define a class e.g.  MyApp implements Runnable
b) define “public void run()” to define thread execution body.
c) create an instance of “MyApp”
d) create required number of “Thread”  class instances by passing “MyApp” instance as an argument (i.e. target )
e) invoke “start()” method on the above created “Thread” class instances.


12)	In extends Thread, if we don’t override “run()” method what will happen ?
Ans:- when scheduler will try to invoke “run()” on a child class, parent class i.e. Thread class run() method will get invoked.

13)	In implements Runnable, if we don’t define “run()”  method what will happen ?
Ans:- compile time error.


14)	What is the Difference between "implements Runnable" and "extends Thread" in Java?

1. Inheritance Option:   The limitation with "extends Thread" approach is that if you extend Thread, you cannot extend any other class. Java does not support multiple inheritance.  In reality, you do not need Thread class behavior, because in order to use a thread you need to instantiate one anyway.
On the other hand, 
implementing the Runnable interface gives you the choice to extend any class you like, but still define behavior that will be run by separate thread.

2. Loosely-coupled : "implements Runnable" makes the code loosely-coupled and easier to read .
Because the code is split into two classes. Thread class for the thread specific code and your Runnable implementation class for your job that should be run by a thread code.
"extends Thread"  makes the code tightly coupled . Single class contains the thread code as well as the job that needs to be done by the thread.

3. Functions overhead :  "extends Thread"  means inheriting all the functions of the Thread class which we may do not need .  The job can be done easily by Runnable without the Thread class functions overhead.
Difference between "implements Runnable"  and "extends Thread"




	 implements Runnable	 extends Thread
		
Inheritance option	extends any java class 	No  
		
Reusability	Yes	No
		
Object Oriented Design	Good,allows composition 	Bad  
		
Loosely Coupled	Yes 	No
		
Function Overhead	No	Yes
		




15)	You are extending Thread or Implementing Runnable. You need to deal with some kind of checked exception inside  run() method. What will u do ?  You will  declare it or handle it inside run() ? Give reason.
Ans:- we have to handle it. We cannot declare it as it goes against overriding and checked exception rule which states that overriding method cannot declare checked exceptions not declared in overridden method.

16)	Normally when does thread die?
Ans:- when “run()” method gets over.

17)	Can we restart dead thread?
Ans: no.

18)	Why start() method is not final?
Ans:- because you can override start() and do something useful before or after calling super.start().


19)	What is main thread?
Ans: main thread is the one created by JVM and it is responsible to invoke main() method.

20)	Explain Race condition with example.
Ans:- There are 2 threads.
	one thread is reading from a file
	other thread is writing to a file.
Race condition means
	while one thread is reading from a file, other thread might write in a file or vice-versa.
Race condition always leads to Data Corruption.

21)	How do we avoid Race condition?
Ans:- by using synchronization.

22)	What is synchronization?
Ans:- synchronization is a technique used to ensure that when multiple threads are sharing same resources, there shouldn’t be a “Race Condition” scenario. In other words, synchronization ensures that the lock on an object is acquired by only one thread at a time.

23)	What exactly happens when we use synchronized keyword?
ans:- There is a concept of object lock.
In java every object has a lock. This lock can be accessed by only one thread at a time. The lock will be released as soon as the thread completes its job and thus another thread can acquire the lock.
	This lock comes into picture only when object has got non-static synchronized method/s or block.
Whichever thread executes the synchronized method first, it acquires the lock.  Other thread/s have to be in "seeking lock state".

Acquiring and Releasing lock happens automatically.

Once a thread acquires a lock on an object, it can have control on all the non-static synchronized methods of that object.

24)	Difference bet’n   synchronized method and block.
Ans:- synchronized keyword
o	method :- all the statements are protected.

o	block :- only those statements are protected which are given inside synchronized block.

25)	Once a thread acquires the lock on an object, what are the things it has control on?
Ans: once a thread acquires the lock on an object, it has control on all the non-static synchronized methods of that object.

26)	What do you mean by “Thread-Safe” class?
Ans:- Thread-safe class means a class having non-static synchronized methods or methods having non-static synchronized blocks.

27)	What is the drawback of synchronization?
Ans: You get Thread-Safety at the cost of performance.

28)	What is class lock?
Ans:- every class has a lock. It is actually a lock on an instance of class “Class”. This is because, whenever any class is loaded in java, it is represented by instance of class “Class”.
The class lock comes into picture in case of synchronized static methods.
Thread which gives a call to synchronized static method can acquire a class lock. Only after thread complete that static method, lock is released.

29)	What is the need for Threads Communication?
Ans:- Even though synchronized method or block is used to avoid "Race Condition", there can be danger of "DeadLock" inside it. 
e.g. if one thread is working inside synchronized block or method and if it gets stuck up !  Imagine what will happen?
Neither this thread can complete and release the lock, nor can other thread acquire the lock.

Solution to this is to have a Communication bet'n threads.
i.e. if the thread realizes it cannot continue, it should come out of synchronized method or block and release the lock. Now other thread will acquire the lock, execute the code and allow the first thread to resume.

30)	What are the methods used for Thread communication? Explain them in brief.
Ans:- in order to have communication bet’n  threads java.lang.Object class has 3 methods which are final
wait() , notify(),  notifyAll()
a) wait
	it will make thread , release the lock and go to wait pool.

b) notify
	it will make the thread to move from wait pool to seeking lock state.

c) notifyAll
	it will make all the threads to move from wait pool to seeking lock state.

31)	If no thread is in the wait pool, and we invoke notify or notifyAll, what will happen?
Ans:- nothing will happen. notify()  and notifyAll() methods are not having any side effects.

32)	wait(), notify()  and  notifyAll() methods can be called only from synchronized method or a block. Why it is so?
ans:- it is because these methods are used to control object lock and object lock comes into picture in case of non-static synchronized method or block.

33)	Difference bet’n sleep and wait.
Ans:- wait() method releases the lock , whereas sleep does not.

34)	What do u mean by Daemon Thread? Give an example.
Ans:- Daemon threads are the threads which are at the mercy of user thread/s. Their only purpose is to serve user defined thread/s. When there is no user thread alive, Daemon thread will die.
	e.g.  garbage collection thread (low priority thread).

35)	What is InterruptedException ?
Ans:-  whenever thread is in a blocked state ie.due to  sleep, join or wait  methods, it can get interrupted by other threads. Whenever blocked thread gets interrupted, it throws "InterruptedException", which is a checked exception.
 
36)	What do u mean by Thread’s born state?
Ans:- it means either you have created instance of the class which is derived from the  Thread class or you have created instance of Thread class.

37)	What is the difference bet’n  runnable and running state?
Ans:- when u invoke “start()” method, thread goes in “runnable” state and when JVM scheduler invokes “run()” method thread goes in “running” state.

38)	From blocked state, thread goes to runnable or running state?
Ans: from blocked state, thread always goes to “runnable” state.


39)	You are using “implements Runnable” technique for multithreading application. What happens when u pass an object implements Runnable to the Thread class constructor and what happens if you don’t pass such object to Thread class constructor?
Ans:- actually when u pass object implements Runnable to Thread class constructor, in Thread class following member is declared:

private Runnable target;

Now when u pass object implements Runnable, the above “target” is initialized inside Thread class constructor.

Thread class has following “run() “ method defined :

@Override
   	public void run() 
{
        if (target != null) {
            target.run();
        }
 } 

Hence it is quite clear, that when u don’t pass object implements Runnable to Thread class constructor, “run” method of Thread class gets invoked and that’s it.
If u pass object implements Runnable then, Thread class run method gets invoked and it invokes “target’s” run method.  Here target means “object implements Runnable”.

40)	What is Re-Entrant lock in java?
Ans: ReentrantLock is mutual exclusive lock, similar to implicit locking provided by synchronized keyword in Java, with extended feature like fairness, which can be used to provide lock to longest waiting thread. Lock is acquired by lock() method and held by Thread until a call to unlock() method.

41)	What is the Difference between ReentrantLock and implicit lock?
Ans:- a) synchronized keyword doesn't support fairness. Any thread can acquire lock once released, no preference can be specified, on the other hand you can make ReentrantLock fair by specifying fairness property, while creating instance of ReentrantLock. Fairness property provides lock to longest waiting thread, in case of conflict.

b) Second difference between synchronized and Reentrant lock is tryLock() method. ReentrantLock provides convenient tryLock() method, which acquires lock only if its available or not held by any other thread. This reduces blocking of thread waiting for lock in Java application.

Similarly tryLock() with timeout can be used to timeout if lock is not available in certain time period.

c) ReentrantLock also provides convenient method to get List of all threads waiting for lock.

d) in case of intrinsic lock if exception is raised, the lock is automatically released. Whereas in case of Reentrant lock if exception is raised, lock is not released.

42)	What is the drawback of Reentrant lock?
Ans: programmer is responsible for acquiring and releasing lock, which is a power but also opens gate for new subtle bugs, when programmer forget to release the lock in finally block.

43)	What is lock fairness in case of Reentrant lock?
Ans: when the lock is released, waiting threads  will acquire it in strict first-come-first-served order. In this mode, it is possible for a thread to have to wait for the lock even though at that precise moment it is not owned by another thread (so that it can go to a "more worthy contender" currently waiting for it).

44)	What is the difference between “tryLock()” and “tryLock(long time, TimeUnit wait)”?
Ans:- boolean  tryLock()
The above method tries to acquire a lock and returns true if it was successful. Otherwise, it immediately returns false, and the thread can go off and do something else.

boolean tryLock(long time, TimeUnit wait)

The above method tries to acquire a lock for a given time and returns true if it was successful. If it does  not acquire a lock within that time , it returns false.
43) Explain “Condition Objects” in case of Reentrant lock.
Ans:- Often, a thread enters a critical section, only to discover that it can’t proceed until a condition is fulfilled. You use a Condition object to manage threads that have acquired a lock but cannot do useful work.
A lock object can have one or more associated condition objects. You obtain a condition object with the “newCondition()” method.
“await()” method of “Condition”  , thread is deactivated and  gives up the lock.
The thread is not made “runnable” when the lock is available. Instead, it stays deactivated until another thread has called “signal()” or  “signalAll()” method on the same condition.
“signal()” method unblocks only a single thread from the wait state, chosen at random. 
“signalAll()” method reactivates all threads that are waiting for the condition.

45)	What are Executors?
Ans: executors are used to implement Thread Pooling concept.
46)	What do you mean by thread pooling?
Ans:- A thread pool contains a number of idle threads that are ready to run. When the run method exits, the thread doesn’t die but stays around to serve the next request. One benefit of a thread pool over creating a new thread for each task is that thread creation and destruction overhead is restricted to the initial creation of the pool, which may result in better performance and better system stability.
47)	How does Executor work?
Ans: You give a Runnable to the Executor, it will create number of Threads for you, and scheduler will then invoke run method for those threads.
48)	What is the advantage of Thread pool over creating threads from the scratch?
Ans:- If requests are frequent and lightweight, as in most server applications, creating a new thread for each request can consume significant computing resources.
In this scenario we should instead use a thread pool. A thread pool contains a number of idle threads that are ready to run. You give a Runnable to the pool, scheduler will then invoke run method for those threads. When the run method exits, the thread doesn’t die but stays around to serve the next request.
49)	What is ForkAndJoin framework?
Ans:- Basically the Fork-Join breaks the task at hand into mini-tasks until the mini-task is simple enough that it can be solved without further breakups. It’s like a divide-and-conquer algorithm. One important concept to note in this framework is that ideally no worker thread is idle. They implement a work-stealing algorithm in that idle workers steal the work from those workers who are busy.

 



Result solve(Problem problem) {
	if (problem is small)
		directly solve problem
	else {
		split problem into independent parts
		fork new subtasks to solve each part
		join all subtasks
		compose result from subresults
	}
}

50)	What is the difference between Fork/Join Framework And ExecutorService?
The main difference between the Fork/Join and the Executor frameworks is the work-stealing algorithm. Unlike the Executor framework, when a task is waiting for the finalization of the sub-tasks it has created using the join operation, the thread that is executing that task (called worker thread ) looks for other tasks that have not been executed yet and begins its execution. By this way, the threads take full advantage of their running time, thereby improving the performance of the application.
51)	What is Work-Stealing algorithm?
ans:- it means Any idle threads can take tasks from the other threads queues if available.

51) Name the existing Implementations in JDK which use Fork/Join Framework.
Ans:- 1) One such implementation, introduced in Java SE 8, is used by the java.util.Arrays class for its parallelSort() methods. These methods are similar to sort(), but leverage concurrency via the fork/join framework. Parallel sorting of large arrays is faster than sequential sorting when run on multiprocessor systems.
2) Parallelism used in Stream API.

1)	What do you mean by serialization and deserialization?
Ans:- Serialization is the process of converting an object's state (including its entire graph) to a sequence of bytes which can be persisted into disk or sent over network to any other running machine. The process of rebuilding those bytes into a live object at some future time is known as deserialization.
2)	What is the need of serialization?
Ans:- When u create an object, it exists for as long as u need it, but under no circumstances does it exist when the program terminates. While this makes sense at first, there are situations in which it would be incredibly useful if an object could exist and hold its information even while the program wasn’t running. Then the next time u started the program, the object would be there and it would have the same information it had, the previous time the program was running.

3)	Object serialization was added to java in order to support which two features?
Ans:- Object serialization was added to the language to support two major features. Java’s RMI and Java Beans.
When JavaBean is used , it’s state information is generally configured at design time. This state information must be stored and later recovered when the program is started. Object serialization performs this task.
	In case of RMI , when object is sent over a network , its copy is sent through serialization mechanism.
4)	What are the requirements we need to meet in order to serialize an object?
Ans:-a) class should implement either Serializable or Externalizable interface
b) class  non-static members should be of serialized nature.
5)  what is the difference between Serializable and Externalizable?
Ans:- In case of Serializable, default serialization process is used. while in case of Externalizable custom Serialization process is used which is implemented by application.

Serialization is a recursive algorithm. i.e. apart from the fields that are required, starting from a single object, until all the objects that can be reached from that object by following instance variables, are also serialized. This includes the super class of the object until it reaches the "Object" class and the same way the super class of the instance variables until it reaches the "Object" class of those variables. Basically all the objects that it can read. This leads to lot of overheads. 

Both serializing and deserializing require the serialization mechanism to discover information about the instance it is serializing. Using the default serialization mechanism, will use reflection to discover all the field values. Also the information about class description is added to the stream which includes the description of all the serializable  superclasses, the description of the class and the instance data associated with the specific instance of the class. Lots of data and metadata and again performance issue. 


Externalization efficiency comes at a price. The default serialization mechanism adapts to application changes due to the fact that metadata is automatically extracted from the class. Externalization on the other hand isn't very flexible and requires you to rewrite your marshalling and unmarshalling code whenever you change your class definitions.

As you know a default public no-arg constructor will be called when de-serializing the objects that implements Externalizable interface. Hence, Externalizable interface can't be implemented by Inner Classes in Java as all the constructors of an inner class in Java will always accept the instance of the enclosing class as a prepended parameter and therefore you can't have a no-arg constructor for an inner class ( exception to this is static inner class ). Inner classes can achieve object serialization by only implementing Serializable interface.

6)	What is SerialVersionUID in case of Serialization?
Ans:- during serialization, runtime associates with each serializable class a version number, called a serialVersionUID, which is used during de-serialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If the receiver has loaded a class for the object that has a different serialVersionUID than that of the corresponding sender’s class, then de-serialization will result in an InvalidClassException. A serializable class can declare its own serialVersionUID explicitly by declaring a field named “serialVersionUID” that must be static, final, and of type long:
private static final long serialVersionUID = 4L;
Here, the serialVersionUID represents your class version.
If a serializable class does not explicitly declare a serialVersionUID, then the serialization runtime will calculate a default serialVersionUID value for that class based on various aspects of the class.
Basically, automatically-generated UID is generated based on a class name, implemented interfaces, and all public and protected members. Changing any of these in any way will change the serialVersionUID.
However, it is strongly recommended that all serializable classes explicitly declare serialVersionUID values, since the default serialVersionUID computation is highly sensitive to class details that may vary depending on JVM implementations and can produce different serialVersionUID in different environments. This can result in unexpected InvalidClassException during de-serialization.
Therefore, to guarantee a consistent serialVersionUID value across different java compiler implementations, a serializable class must declare an explicit serialVersionUID value. It is also strongly advised that explicit serialVersionUID declarations use the private modifier in serialVersionUID where possible, since such declarations apply only to the immediately declaring class. SerialVersionUID field is not useful as inherited member.

7)	What happens when we deserialize an object?
Ans:- 1)	The object is read from the stream.
2)	The JVM determines (through info stored with the serialized object ) the object’s class type.
3)	The JVM attempts to find and load the object’s class. If the JVM can’t find and / or load the class, the JVM throws an exception and deserialization fails.
4) the serialVersionUID of the class representing the deserialized object is extracted and compared with the serialVersionUID of the loaded class.
If the numbers do not match then, InvalidClassException is thrown.

5)A new object is given space on the heap.

6) if class implements Serializable, 

	(i) serialized object’s constructor does not run ! obviously , if the constructor ran, it would restore the state of the object back to its original ‘new’ state and that’s not what we want. We want the object to be restored to the state it had when it was serialized, not when it was first created.
  (ii)	If the object has a non-serializable class somewhere up its inheritance tree, the constructor for that non-serializable class will run along with any constructors above that. Once the constructor chaining begins, you can’t stop it , which means all superclasses, beginning with the first non-serializable one, will reinitialize their state.
	(iii) if the class has overridden "readObject()" method in which we are trying to initialize instance member/s with the help of serialized state, it is invoked.
		if not, The object’s instance variables are given the values from the serialized state. Transient variables are given a value of null for object references and defaults (0, false, etc. ) for primitives.

7) if the class implements Externalizable.
	
	(i) serialized object’s no-arg constructor gets invoked.
	(ii) readExternal() method is invoked which we have defined.
 



8) What is transient variable in Java?
Ans:- If you don't need to save and restore any member variable (e.g., the password kept in a String object), the private modifier will not help you. Serialized information can be read in a file or in a captured network packet. You may implement the Externalizable interface, which is demonstrated in the previous paragraph. In this case, nothing is written automatically, and you can control the entire process.
However, serializable objects are much more convenient because everything is serialized there automatically. You can forbid serialization of any member variable object with the transient modifier. It tells the JVM: "Do not save and restore this field, please; somebody else will take care of this field." 
9) When should we use transient keyword in java?
Ans:- a) First and very logical case would be where you may have fields that are derived/calculated from other fields within instance of class. They should be calculated programmatically everytime rather than having the state be persisted via serialization. An example could be time-stamp based value; such as age of a person OR duration between a timestamp and current timestamp. In both cases, you would be calculating value of variable based on current system time rather than when the instance was serialized.
b)	Second logical example can be any secure information which should not leak outside the JVM in any form (either in database OR byte stream).
c)	Another example could be fields which are not marked as “Serializable” inside JDK or application code. Classes which do not implement Serializable interface and are referenced within any serializable class, cannot be serialized; and will throw “java.io.NotSerializableException” exception. These non-serializable references should be marked “transient” before serializing the main class.
d)	And lastly, there are times when it simply doesn’t make sense to serialize some fields. Period. For example, In any class if you have added a logger reference, then what’s use of serializing that logger instance. Absolutely no use. You serialize the information which represent the state of instance, logically. Loggers never share the state of an instance. They are just utilities for programming/debugging purpose. Similar example can be reference of a Thread class. Threads represent a state of a process at any given point of time, and there is no use to store thread state with your instance; simply because they do not constitute the state of your class’s instance.

10)  What are the things get written when u serialize an object?
•	Ans: it writes out the metadata (description) of the class associated with an instance such as length of the class, the name of the class, serialVersionUID (or serial version), the number of fields in this class.
•	Then it recursively writes out the metadata of the superclass until it finds java.lang.object. 

•	Once it finishes writing the metadata information, it then starts with the actual data associated with the instance. But this time, it starts from the top most superclass. 

•	Finally it writes the data of objects associated with the instance starting from metadata to actual content recursively.


11) If a class is Serializable but its super class is not, what will be the state of the instance variables inherited from super class after deserialization?
ans:- Java serialization process  only continues in object hierarchy till the class is Serializable i.e. implements Serializable interface in java  and values of the instance variables inherited from super class will be initialized by calling constructor of Non-Serializable Super class during deserialization process.

12) Suppose super class of a new class implement Serializable interface, how can you avoid new class to being serialized?

ans:- If Super Class of a Class already implements Serializable interface in Java then its already Serializable in Java, since you can not unimplemented an interface its not really possible to make it Non Serializable class but yes there is a way to avoid serialization of new class. To avoid java serialization you need to implement writeObject() and readObject()method in your Class and need to throw NotSerializableException from those method. This is another benefit of customizing java serialization process

13) Suppose you have a class which you serialized it and stored in persistence and later modified that class to add a new field. What will happen if you deserialize the object already serialized?
ans:- It depends on whether class has its own SerialVersionUID or not. If we don't provide serialVersionUID in our code runtime system will generate it. By adding any new field there is chance that new serialVersionUID generated for that class version is not the same of already serialized object and in this case JVM will raise  java.io.InvalidClassException and this is the reason its recommended to have your own serialVersionUID in code and make sure to keep it same always for a single class.

14) Which kind of variables is not serialized during Java Serialization?
ans:- Since static variables belong to the class and not to an object they are not the part of the state of object so they are not saved during Java Serialization process. Transient variables are also not included in java serialization process and are not the part of the object’s serialized state.

15) Does  “java.lang.Object” class implement  “Serializable”  ? explain with reason.

Ans:- No.

	Because in that case each and every class would have become “Serializable”.

So what ? What’s a problem ? Can’t all the classes in java become “Serializable” ?
	They can. But it does not make any sense in case of some classes , to become serializable.
there are some classes that don't have an obvious serialization. Consider, for 
example, an instance of  FileInputStream. An instance of FileInputStream represents a file. Suppose, for example, it was created using the following line of code:
FileInputStream file = new FileInputStream ("c:\\temp\\foo");
It's not at all clear what should be written out when this is serialized. The problem is that the file itself has a different lifecyle than the serialized data. The file might be edited, or deleted entirely, while the serialized information remains unchanged. Or the serialized information might be used to restart the application on another machine, where "C:\\temp\\foo" is the name of an entirely different file.
Another example is provided by the Thread class. A thread represents a flow of execution within a particular JVM. You would not only have to store the stack, and all the local variables, but also all the related locks and threads, and restart all the threads properly when the instance is deserialized. 
TIP:   Things get worse when you consider platform dependencies. In general, any class that involves native code is not really a good candidate for serialization.




16) What happens when one of the members in the class doesn't implement Serializable interface?

ans:- If you try to serialize an object of a class which implements Serializable, but the object includes a reference to an non- Serializable class then a ‘NotSerializableException’ will be thrown at runtime.

17) What happens when base  class doesn't implement Serializable interface but sub class implements?
Ans:- If you try to serialize an object of a class which implements Serializable but its base class does not , at the most what will happen is base class members won’t get serialized. Java serialization process only continues in object hierarchy till the class is Serializable i.e. implements Serializable interface in Java and values of the instance variables inherited from super class will be initialized by calling constructor of Non-Serializable Super class during deserialization process.



18) Can you Customize Serialization process or can you override default Serialization process in Java?

ans:- The answer is yes you can. We all know that for serializing an object ObjectOutputStream.writeObject (saveThisobject) is invoked and for reading object ObjectInputStream.readObject() is invoked but there is one more thing which Java Virtual Machine provides you is to define two methods “private void writeObject(ObjectOutputStream out)” and “private void readObject(ObjectInputStream in)” in your class. If you define these two methods in your class then JVM will invoke these two methods instead of applying default serialization mechanism. You can customize behaviour of object serialization and deserialization here by doing any kind of pre or post processing task. Important point to note is making these methods private to avoid being inherited, overridden or overloaded. Since only Java Virtual Machine can call private method, integrity of your class will remain and Java Serialization will work as normal.


19) While customizing serialization process, if we define “readObject()” and “writeObject()” with the accessibility modifiers other than “private” what will happen?
Ans:- If these methods are not private, they will be ignored by JVM.

20) Can we transfer a Serialized object via network?
Ans:-Yes you can transfer a Serialized object via network because Java serialized object remains in form of bytes which can be transmitted via network. You can also store serialized object in Disk or database as Blob.
21) How many ways we can create objects in java?
Ans:- There are five total ways to create objects in Java, which are explained below.
Using new keyword	} → constructor gets called
Using newInstance() method of Class class	} → constructor gets called
Using newInstance() method of Constructor class	} → constructor gets called
Using clone() method	} → no constructor call
Using deserialization	} → no constructor call


21) What is the difference between Standard IO and NIO?
Ans:- First main difference between the standard IO and NIO is, standard IO is based on streams and NIO is buffer oriented. Buffer oriented operations provide flexibility in handling data. In buffer oriented NIO, data is first read into a buffer and then it is made available for processing. So we can move back and forth in the buffer. But in the case of streams it is not possible.
Second main difference is, blocking and non-blocking IO operations. In case of streams, a thread will be blocked until it completes the IO operation. Wherein the NIO allows for non-blocking operations. If the data is not available for IO operations, then the thread can do something else and need not stay in blocked mode.





 

1)	What are Generics in Java?
Ans: Generics are a facility of generic programming that were added to the Java programming language in 2004 within J2SE5.0. They allow "a type or method to operate on objects of various types while providing compile-time type safety.

2)	How does Generic provide Type-safety?
Ans: The following block of Java code illustrates a problem that exists when not using generics. First, it declares an ArrayListof type Object. Then, it adds a String to the ArrayList. Finally, it attempts to retrieve the added String and cast it to an Integer.
List v = new ArrayList();
v.add("test");
Integer i = (Integer)v.get(0); // exception: ClassCastException
Although the code compiles without error, it throws a runtime exception (java.lang.ClassCastException) when executing the third line of code. This type of problem can be avoided by using generics and is the primary motivation for using generics.
Using generics, the above code fragment can be rewritten as follows:
List<String> v = new ArrayList<String>();
v.add("test");
Integer i = v.get(0); // (type error)  Compile time error
The type parameter String within the angle brackets declares the ArrayList to be constituted of String. With generics, it is no longer necessary to cast the third line to any particular type, because the result of v.get(0) is defined as String by the code generated by the compiler.
Compiling the third line of this fragment with J2SE 5.0 (or later) will yield a compile-time error because the compiler will detect that v.get(0) returns String instead of Integer. 
3)	What do you mean by type-erasure?
Ans:- all the generic information applied in java application is removed by compiler while compiling the code. This is known as “type-erasure”.
i.e. Type erasure is the technique using which the Java compiler translates generic / parameterized type to raw type in Java generics.
4) explain <? extends T> in java generics.
Ans:- it means u can pass T or its sub type. Here you can’t add anything to the collection. E.g.

Void disp(List<? Extends Animal> mylist)
{
}

U can invoke disp() by passing say List implementation of Tiger. But inside disp() using mylist u can’t add anything. This is because compiler will have no way to detect a problem caused by adding Dog inside list which is actually meant for Tiger.


5)	Explain <? super T> in java generics.
Ans:- it means u can pass T or its base type. Here you can add inside collection. E.g.

Void disp(List<? super Dog> mylist)
{
}

U can invoke disp() by passing say List implementation of Dog or its base type ( say Animal or Object). Now  inside disp() using mylist u can add Dog. This is because mylist variable will point to List implementation of Dog or Animal or Object. And u can see there is absolutely no problem in adding Dog inside List of Dog or Animal or Object.


6)	What is the rule of upcast and generics?
Ans:- upcast applies to the "base" type of the collection and not the “generic” type.
e.g.

Following code does not work

class Parent{}
class Child extends Parent{}

List<Parent>mylist=new ArrayList<Child>();

Because the rule is, generic type of reference and generic type of the object to which it refers must be identical. Upcast applies to "base" type, and the meaning of "base" is collection class itself.
Here List and ArrayList are type “base” and Parent and Child are type “generics”.
7)	Why the following statement will not work?
List<Animal> mylist=new ArrayList<Dog>();
The reason the compiler won't let u pass an ArrayList<Dog> into a method that takes an ArrayList<Animal>, is because within the method, that parameter is of type ArrayList<Animal>, and that means u could put any kind of Animal into it. There would be no way for compiler to stop u from putting a Cat into a List that was originally declared as <Dog>, but is now referenced from the <Animal> parameter.
8)	Given the following two scenarios:
a)	public void addAnimal(Animal arr[])
{
	System.out.println(arr[0]);
}

Dog d[]={new Dog(),new Dog()};
addAnimal(d);

b)	public void addAnimal(List<Animal> ref)
{
	System.out.println(ref);

}
addAnimal(new ArrayList<Dog>());
explain with reason which scenario is legal at compile-time and which is not.
Ans:- scenario a is legal at compile-time whereas b is not.
The reason the compiler won't let u pass an ArrayList<Dog> into a method that takes an ArrayList<Animal>, is because within the method, that parameter is of type ArrayList<Animal>, and that means u could put any kind of Animal into it. There would be no way for compiler to stop u from putting a Cat into a List that was originally declared as <Dog>, but is now referenced from the <Animal> parameter.
	Now the question arises, why compiler allows it in case of arrays and not in collection?
	The reason u can get away with compiling this for arrays is because there is a runtime exception (ArrayStoreException) that will prevent u from putting the wrong type of object into an array. If u send a Dog array into the method that takes an Animal array, and u add only Dogs (including Dogs subtypes) into the array now referenced by Animal, no problem. But if u do try to add Cat to the object that is actually a Dog array, u will get the exception.
	But there is no equivalent exception for generics, because of type erasure!
In other words, at runtime the JVM knows the type of arrays but does not know the type of collection. All the generic type information is removed during compilation, so by the time it gets to the JVM, there is simply no way to recognize the disaster of putting a Cat into an ArrayList<Dog>. that is at runtime the JVM would have no way to stop u from adding a Cat to what was created as a Dog collection.
9)	What is the difference between List<?> mylist and  List<Object> mylist?
Ans:- There is a huge difference. List<?>, which is the wildcard<?> without the keywords extends or super, simply means "any type". So that means any type of List can be assigned to the argument. That could be a List of <Dog>, <Integer> etc. whatever. And using the wildcard alone, without the keyword super(followed by a type),means that u cannot add anything to the list referred to as List<?>.
	List<Object> is completely different from List<?>. List<Object> means that the method can take only a List<Object>. Not a List<Dog> or List<Cat>. It does, however, mean that u can add to the list, since the compiler has already made certain that u r passing only a valid List<Object> into the method.

1)	What is the importance of Collection API?
Ans:- What if u want to have a collection of data items ?
	e.g. Strings, numbers, characters ,objects etc.
one way is to create array. They are efficient.
But if we have following needs:
a)	Dynamic array
b)	Sorted data
c)	uniqueness
d)	key-value storage
e)	effective way of persisting 

Arrays cannot fulfill above needs. We have to use containers for that.

Containers
	Give us advantages such as
•	Dynamic
•	Sorted Order
•	Uniqueness
•	Thread-safe
•	Performance 
•	Key-value storage, convenient for retrieval by passing a key.
•	Provide effective way of storing and maintaining data inside the file system.

Iterators  
	Allow us to traverse through the container.
Algorithms
	Allow us to perform tasks such as min,max, sort etc. on the data structure.
2)	What are the basic interfaces of Java Collections Framework?
Ans:- Collection is the root of the collection hierarchy. A collection represents a group of objects known as its elements. The Java platform doesn’t provide any direct implementations of this interface.
Set is a collection that cannot contain duplicate elements. This interface models the mathematical set abstraction and is used to represent sets, such as the deck of cards.
List is an ordered collection and can contain duplicate elements. You can access any element from its index. List is more like array with dynamic length.
A Map is an object that maps keys to values. A map cannot contain duplicate keys: Each key can map to at most one value.
Some other interfaces are Queue, Dequeue, Iterator, SortedSet, SortedMap and ListIterator.

3)	Why Collection doesn’t extend Cloneable and Serializable interfaces?
Ans:- Collection interface specifies group of Objects known as elements. How the elements are maintained is left up to the concrete implementations of Collection. For example, some Collection implementations like List allow duplicate elements whereas other implementations like Set don’t.
A lot of the Collection implementations have a public clone method. However, it doesn’t really make sense to include it in all implementations of Collection. This is because Collection is an abstract representation. What matters is the implementation.
The semantics and the implications of either cloning or serializing come into play when dealing with the actual implementation; so concrete implementation should decide how it should be cloned or serialized, or even if it can be cloned or serialized.
So mandating cloning and serialization in all implementations is actually less flexible and more restrictive. The specific implementation should make the decision as to whether it can be cloned or serialized.
4)	Why Map interface doesn’t extend Collection interface?
Ans:- Although Map interface and it’s implementations are part of Collections Framework, Map are not collections and collections are not Map. Hence it doesn’t make sense for Map to extend Collection or vice versa.
If Map extends Collection interface, then where are the elements? Map contains key-value pairs and it provides methods to retrieve list of Keys or values as Collection but it doesn’t fit into the “group of elements” pattern.
5)	What is an Iterator?
Ans:- Iterator interface provides methods to iterate over any Collection. We can get iterator instance from a Collection using iterator() method. Iterator takes the place of Enumeration in the Java Collections Framework. Iterators allow the caller to remove elements from the underlying collection during the iteration. Java Collection iterator provides a generic way for traversal through the elements of a collection and implements Iterator Design Pattern.
6)	What is difference between Enumeration and Iterator interface?
ans:- both are used to traverse through the collection implementations. The difference is Iterators allow the caller to remove elements from the underlying collection that is not possible with Enumeration. Iterator method names have been improved to make its functionality clear.
7)	What is the difference between Iterator and ListIterator?
Ans:- 
•	We can use Iterator to traverse Set and List collections whereas ListIterator can be used with Lists only.
•	Iterator can traverse in forward direction only whereas ListIterator can be used to traverse in both the directions.
•	ListIterator inherits from Iterator interface and comes with extra functionalities like adding an element, replacing an element, getting index position for previous and next elements.
8)	What are different ways to iterate over a list?
Ans:- We can iterate over a list in two different ways – using iterator and using for-each loop.
	List<String>  strList = new ArrayList<String>();
//using for-each loop
for(String obj : strList)
{
    System.out.println(obj);
}

//using iterator
Iterator<String>  it = strList.iterator();
while(it.hasNext())
{
    String obj = it.next();
    System.out.println(obj);
}
Using iterator is more thread-safe because it makes sure that if underlying list elements are modified, it will throw ConcurrentModificationException.

9)	What do you understand by iterator fail-fast property?
Ans:-Iterator fail-fast property checks for any modification in the structure of the underlying collection everytime we try to get the next element. If there are any modifications found, it throws ConcurrentModificationException. All the implementations of Iterator in Collection classes are fail-fast by design except the concurrent collection classes like ConcurrentHashMap and CopyOnWriteArrayList.
10)	 What is the difference between iterator being fail-fast and fail-safe?
Ans:- Iterator fail-safe property work with the clone of underlying collection, hence it’s not affected by any modification in the collection. By design, all the collection classes in java.util package are fail-fast whereas collection classes in java.util.concurrent are fail-safe.
Fail-fast iterators throw ConcurrentModificationException whereas fail-safe iterator never throws ConcurrentModificationException.
11)	 Why there are no concrete implementations of Iterator interface?
Ans:- Iterator interface declare methods for iterating a collection but its implementation is responsibility of the Collection implementation classes. Every collection class that returns an iterator for traversing has its own Iterator implementation nested class.
This allows collection classes to choose whether iterator is fail-fast or fail-safe. For example ArrayList iterator is fail-fast whereas CopyOnWriteArrayList iterator is fail-safe.
Following are some of the contents of  “ArrayList” class:
public Iterator<E> iterator() {
        return new Itr();
    }

    /**
     * An optimized version of AbstractList.Itr
     */
    private class Itr implements Iterator<E> {
        int cursor;       // index of next element to return
        int lastRet = -1; // index of last element returned; -1 if no such
        int expectedModCount = modCount;

        public boolean hasNext() {
            return cursor != size;
        }

        @SuppressWarnings("unchecked")
        public E next() {
            checkForComodification();
            int i = cursor;
            if (i >= size)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }

        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        @Override
        @SuppressWarnings("unchecked")
        public void forEachRemaining(Consumer<? super E> consumer) {
            Objects.requireNonNull(consumer);
            final int size = ArrayList.this.size;
            int i = cursor;
            if (i >= size) {
                return;
            }
            final Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length) {
                throw new ConcurrentModificationException();
            }
            while (i != size && modCount == expectedModCount) {
                consumer.accept((E) elementData[i++]);
            }
            // update once at end of iteration to reduce heap write traffic
            cursor = i;
            lastRet = i - 1;
            checkForComodification();
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }

Following are some of the contents of  “CopyOnWriteArrayList”:

public Iterator<E> iterator() 
{
        return new COWIterator<E>(getArray(), 0);
}


static final class COWIterator<E> implements ListIterator<E> {
        /** Snapshot of the array */
        private final Object[] snapshot;
        /** Index of element to be returned by subsequent call to next.  */
        private int cursor;

        private COWIterator(Object[] elements, int initialCursor) {
            cursor = initialCursor;
            snapshot = elements;
        }

        public boolean hasNext() {
            return cursor < snapshot.length;
        }

        public boolean hasPrevious() {
            return cursor > 0;
        }

        @SuppressWarnings("unchecked")
        public E next() {
            if (! hasNext())
                throw new NoSuchElementException();
            return (E) snapshot[cursor++];
        }

        @SuppressWarnings("unchecked")
        public E previous() {
            if (! hasPrevious())
                throw new NoSuchElementException();
            return (E) snapshot[--cursor];
        }

        public int nextIndex() {
            return cursor;
        }

        public int previousIndex() {
            return cursor-1;
        }

        /**
         * Not supported. Always throws UnsupportedOperationException.
         * @throws UnsupportedOperationException always; {@code remove}
         *         is not supported by this iterator.
         */
        public void remove() {
            throw new UnsupportedOperationException();
        }

        /**
         * Not supported. Always throws UnsupportedOperationException.
         * @throws UnsupportedOperationException always; {@code set}
         *         is not supported by this iterator.
         */
        public void set(E e) {
            throw new UnsupportedOperationException();
        }

        /**
         * Not supported. Always throws UnsupportedOperationException.
         * @throws UnsupportedOperationException always; {@code add}
         *         is not supported by this iterator.
         */
        public void add(E e) {
            throw new UnsupportedOperationException();
        }

        @Override
        public void forEachRemaining(Consumer<? super E> action) {
            Objects.requireNonNull(action);
            Object[] elements = snapshot;
            final int size = elements.length;
            for (int i = cursor; i < size; i++) {
                @SuppressWarnings("unchecked") E e = (E) elements[i];
                action.accept(e);
            }
            cursor = size;
        }
    }

    /**
     * Returns a view of the portion of this list between
     * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.
     * The returned list is backed by this list, so changes in the
     * returned list are reflected in this list.
     *
     * <p>The semantics of the list returned by this method become
     * undefined if the backing list (i.e., this list) is modified in
     * any way other than via the returned list.
     *
     * @param fromIndex low endpoint (inclusive) of the subList
     * @param toIndex high endpoint (exclusive) of the subList
     * @return a view of the specified range within this list
     * @throws IndexOutOfBoundsException {@inheritDoc}
     */
    public List<E> subList(int fromIndex, int toIndex) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            if (fromIndex < 0 || toIndex > len || fromIndex > toIndex)
                throw new IndexOutOfBoundsException();
            return new COWSubList<E>(this, fromIndex, toIndex);
        } finally {
            lock.unlock();
        }
    }




12)	How HashMap works in Java?
Ans:- HashMap stores key-value pair in Map.Entry static nested class implementation. HashMap works on hashing algorithm and uses hashCode() and equals() method in put and get methods.
When we call put method by passing key-value pair, “put” method invokes “hash()” method on Key hashCode() and  finds out the index to store the key-value pair. Now when u put another entry, there are two scenarios of hash collision:
a)	Hashcode of the given entry is same as existing entry/entries. – in this case == is called on key, if it matches, it overwrites the value. If == doesn’t match, then “equals()” is invoked ,if it returns true then  overwrites the value. If not linked list is formed.
b)	 Hashcode of the given entry is different from the existing keys in the map, but index returned from the “hash()” is same as that of existing entries. – in this case also linked list is formed.
a and b prove that hash collision can happen in two cases ie. When hashcode is same as existing entries or when hashcode  is different but index is same as that of existing entries.
When we call get method by passing Key, again it uses “hash()” function which uses the hashCode() of given key to find the index in the array and then uses ==. If == returns true, it returns the value , if it returns false,then equals() method is invoked , if it returns true value is returned otherwise next node inside the linkedlist is traversed to find the correct Entry and return it’s value. Below image will explain these details clearly.
 
13)	What are the changes java8 brought to the Map implementations?
Ans:- Prior to Java 8, HashMap and all other hash table based Map implementation classes in Java handle collision by chaining, i.e. they use linked list to store map entries which ended in the same bucket due to a collision. If a key end up in same bucket location where an entry is already stored then this entry is just added at the head of the linked list there. In the worst case this degrades the performance of the get() method of HashMap to O(n) from O(1). In order to address this issue in the case of frequent HashMap collisions, Java8 has started using a balanced tree instead of linked list for storing collided entries. This also means that in the worst case you will get a performance boost from O(n) to O(log n).

The threshold of switching to the balanced tree is defined as TREEIFY_THRESHOLD constant in java.util.HashMap JDK 8 code.  Currently, it's value is 8, which means if there are more than 8 elements in the same bucket than HashMap will use a tree instead of linked list to hold them in the same bucket. 
So far (until JDK 8) only ConcurrentHashMap, LinkedHashMap and HashMap will use the balanced tree in case of a frequent collision. Also, this feature will not available to all hash table based classes in Java e.g. Hashtable will not have this feature because of its legacy nature and given that this feature can change the traditional legacy iteration order of Hashtable. 

14)	What is the importance of hashCode() and equals() methods?
ans:- HashMap uses Key object hashCode() and equals() method to determine the index to put the key-value pair. These methods are also used when we try to get value from HashMap. If these methods are not implemented correctly, two different Key’s might produce same hashCode() and equals() output and in that case rather than storing it at different location, HashMap will consider them same and overwrite them. 
Similarly all the collection classes that doesn’t store duplicate data use hashCode() and equals() to find duplicates, so it’s very important to implement them correctly. The implementation of equals() and hashCode() should follow these rules.
•	If o1.equals(o2), then o1.hashCode() == o2.hashCode()should always be true.
•	If o1.hashCode() == o2.hashCode is true, it doesn’t mean that o1.equals(o2) will be true.
15)	Can we use any class as Map key?
Ans:- We can use any class as Map Key, however following points should be considered before using them.
•	If the class overrides equals() method, it should also override hashCode() method.
•	If a class field is not used in equals(), you should not use it in hashCode() method.
•	Best practice for user defined key class is to make it immutable in order to ensure that hashCode() and equals() will not change in future that will solve any issue with mutability.
For example, let’s say I have a class MyKey that I am using for HashMap key.

//MyKey name argument passed is used for equals() and hashCode()
MyKey key = new MyKey("Pankaj"); //assume hashCode=1234
myHashMap.put(key, "Value");
 
// Below code will change the key hashCode() and equals()
// but it's location is not changed.
key.setName("Amit"); //assume new hashCode=7890
 
//below will return null, because HashMap will try to look for key
//in the same index as it was stored but since key is mutated, 
//there will be no match and it will return null.
myHashMap.get(key); 
•	This is the reason why String and Integer are mostly used as HashMap keys.
16)	 How to convert an array of String to List?
Ans:- 




	 String array
String[] words = {“one”,”two”,”three”};
//Use Arrays utility class
List wordList = Arrays.asList(words);
//Now you can iterate over the list
Note that this function is not specific to String class, it will return List of element of any type, of which the array is. e.g.



	//String array
Integer[] nums = {1,2,3,4};
//Use Arrays utility class
List numsList = Arrays.asList(nums);
17)	How HashSet store elements?
Ans:- You must know that HashMap store key-value pairs, with one condition i.e. keys will be unique. HashSet uses Map’s this feature to ensure uniqueness of elements. In HashSet class, a map declaration is as below:



	private transient HashMap<E,Object> map;
 
//This is added as value for each key
private static final Object PRESENT = new Object();
So when you store a element in HashSet, it stores the element as key in map and “PRESENT” object as value. (See declaration above).


	public boolean add(E e) 
{
return map.put(e, PRESENT)==null;
}

18)	Difference between HashMap or TreeMap?
Ans:- HashMap is used to store key-value pairs and allows to perform many operations on such collection of pairs.
TreeMap is special form of HashMap. It maintains the ordering of keys which is missing in HashMap class. This ordering is by default “natural ordering”. The default ordering can be override by providing an instance of Comparator class, whose compare method will be used to maintain ordering of keys.
All keys inserted into the map must implement the Comparable interface (this is necessary to decide the ordering.
19)	Difference between Set and List.
•	Ans:- Set is unordered collection where List is ordered collection based on zero based index.
•	List allow duplicate elements but Set does not allow duplicates.
•	List does not prevent inserting null elements (as many you like), but Set will allow only one null element.
20)	if you want to store object of any user defined class as a key inside TreeMap or as an element inside TreeSet, what care u will take?
Ans:- The class has to either implement Comparable or Comparator interface.
21)	Difference between HashMap and HashTable
Ans:- There are several differences between HashMap and Hashtable in Java:
•	Hashtable is synchronized, whereas HashMap is not.
•	Hashtable does not allow null keys or values. HashMap allows one null key and any number of null values.
•	The third significant difference between HashMap vs Hashtable is that Iterator in the HashMap is a fail-fast iterator while the enumerator for the Hashtable is not.
22)	Difference between Vector and ArrayList.
•	Ans:- All the methods of Vector is synchronized. But, the methods of ArrayList is not synchronized.
•	Vector is a Legacy class added in first release of JDK. ArrayList was part of JDK 1.2, when collection framework was introduced in java.
•	By default, Vector doubles the size of its array when it is re-sized internally. But, ArrayList increases by half of its size when it is re-sized.
23)	Difference between Iterator and Enumeration.
Ans:- Iterators differ from enumerations in three ways:
•	Iterators allow the caller to remove elements from the underlying collection during the iteration with its remove() method. You can not add/remove elements from a collection when using enumerator.
•	Enumeration is available in legacy classes i.e Vector/Stack etc. whereas Iterator is available in all modern collection classes.
•	Another minor difference is that Iterator has improved method names e.g. Enumeration.hasMoreElement() has become Iterator.hasNext(), Enumeration.nextElement() has become Iterator.next() etc.
24)	Difference between Iterator and ListIterator.
Ans:- There are three Differences are there:
•	We can use Iterator to traverse Set and List and also Map type of Objects. But List Iterator can be used to traverse for List type Objects, but not for Set type of Objects.
•	By using Iterator we can retrieve the elements from Collection Object in forward direction only whereas List Iterator, which allows you to traverse in either directions using hasPrevious() and previous() methods.
•	ListIterator allows you modify the list using add() remove() methods. Using Iterator you can not add, only remove the elements.
25)	Difference between ArrayList and LinkedList.
•	Ans:- LinkedList store elements within a doubly-linked list data structure. ArrayList store elements within a dynamically resizing array.
•	LinkedList allows for constant-time insertions or removals, but only sequential access of elements. In other words, you can walk the list forwards or backwards, but grabbing an element in the middle takes time proportional to the size of the list. ArrayLists, on the other hand, allow random access, so you can grab any element in constant time. But adding or removing from anywhere but the end requires shifting all the latter elements over, either to make an opening or fill the gap.
•	LinkedList has more memory overhead than ArrayList because in ArrayList each index only holds actual object (data) but in case of LinkedList each node holds both data and address of next and previous node.
26)	How to make a collection read only?
Ans:- Use following methods:
•	Collections.unmodifiableList(list);
•	Collections.unmodifiableSet(set);
•	Collections.unmodifiableMap(map);
These methods takes collection parameter and return a new read-only collection with same elements as in original collection.
27)	How to make a collection thread safe?
Ans:- Use below methods:
•	Collections.synchronizedList(list);
•	Collections.synchronizedSet(set);
•	Collections.synchronizedMap(map);
Above methods take collection as parameter and return same type of collection which are synchronized and thread safe.
28)	Why there is no method like Iterator.add() to add elements to the collection?
Ans:- The sole purpose of an Iterator is to enumerate through a collection. All collections contain the add() method to serve your purpose. There would be no point in adding to an Iterator because the collection may or may not be ordered. And add() method can not have same implementation for ordered and unordered collections.
29)	What do you understand by iterator fail-fast property?
Ans:- Fail-fast Iterators fail as soon as they realized that structure of Collection has been changed since iteration has begun. Structural changes means adding, removing or updating any element from collection while one thread is Iterating over that collection.
Fail-fast behaviour is implemented by keeping a modification count and if iteration thread realizes the change in modification count it throws ConcurrentModificationException.
30)	What do you understand by iterator is fail-safe?
Ans:- Fail-safe iterators are just opposite to fail-fast. They never fail if you modify the underlying collection on which they are iterating, because they work on clone of Collection instead of original collection and that’s why they are called as fail-safe iterator.
Iterator of CopyOnWriteArrayList is an example of fail-safe Iterator also iterator written by ConcurrentHashMap keySet is also fail-safe iterator and never throw ConcurrentModificationException.
31)	How to avoid ConcurrentModificationException while iterating a collection?
Ans:- You should first try to find another alternative iterator which are fail-safe. For example if you are using List and you can use ListIterator. If it is legacy collection, you can use enumeration.
If above options are not possible then you can use one of three changes:
•	If you are using JDK1.5 or higher then you can use ConcurrentHashMap and CopyOnWriteArrayList classes. It is the recommended approach.
•	You can convert the list to an array and then iterate on the array.
•	You can lock the list while iterating by putting it in a synchronized block.
Please note that last two approaches will cause a performance hit.
32)	What is UnsupportedOperationException?
Ans:- This exception is thrown on invoked methods which are not supported by actual collection type.
For example, if you make a read-only list list using “Collections.unmodifiableList(list)” and then call add() or remove() method, what should happen. It should clearly throw UnsupportedOperationException. This exception is also thrown when we try to invoke “add()” or “remove()” methods on fail-safe iterator of CopyOnWriteArrayList or ConcurrentHashMap.
33)	What is the importance of hashCode() and equals() methods? How they are used in Java?
Ans:- The java.lang.Object has two methods defined in it. They are - public boolean equals(Object obj) public int hashCode(). These two methods are used heavily when objects are stored in collections. There is a contract between these two methods which should be kept in mind while overriding any of these methods. The Java API documentation describes it in detail. The hashCode() method returns a hash code value for the object. This method is supported for the benefit of hashtables such as those provided by java.util.Hashtable or java.util.HashMap. The general contract of hashCode is: Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application. If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hashtables. As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. The equals(Object obj) method indicates whether some other object is "equal to" this one. The equals method implements an equivalence relation on non-null object references: It is reflexive: for any non-null reference value x, x.equals(x) should return true. It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true. It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. It is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified. For any non-null reference value x, x.equals(null) should return false. The equals method for class Object implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true). Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes. A practical Example of hashcode() & equals(): This can be applied to classes that need to be stored in Set collections. Sets use equals() to enforce non-duplicates, and HashSet uses hashCode() as a first-cut test for equality. Technically hashCode() isn't necessary then since equals() will always be used in the end, but providing a meaningful hashCode() will improve performance for very large sets or objects that take a long time to compare using equals().

34)	What is the difference between CopyOnWriteArrayList and ArrayList in Java?
Ans:- a) First and foremost difference between CopyOnWriteArrayList and ArrayList in Java is that CopyOnWriteArrayList is a thread-safe collection while ArrayList is not thread-safe and cannot be used in multi-threaded environment.

b) Second difference between ArrayList and CopyOnWriteArrayList is that Iterator of ArrayList is fail-fast and throw ConcurrentModificationException once detect any modification in List once iteration begins but Iterator of CopyOnWriteArrayList is fail-safe and doesn't throw ConcurrentModificationException.

c) Third difference between CopyOnWriteArrayList vs ArrayList is that Iterator of former doesn't support remove operation while Iterator of later supports remove() operation.

35)	Which implementation of the List interface provides for the fastest insertion of a new element into the middle of the list? 
Ans:- ArrayList and Vector both use an array to store the elements of the list. When an element is inserted into the middle of the list the elements that follow the insertion point must be shifted to make room for the new element. The LinkedList is implemented using a doubly linked list; an insertion requires only the updating of the links at the point of insertion. Therefore, the LinkedList allows for fast insertions and deletions.
36)	How do you remove an entry from a Collection? and subsequently what is difference between remove() method of Collection and remove() method of Iterator, which one you will use, while removing elements during iteration?

ans:- Collection interface defines remove(Object obj) method to remove objects from Collection. List interface adds another method remove(int index), which is used to remove object at specific index. You can use any of these method to remove an entry from Collection, while not iterating. Things change, when you iterate. Suppose you are traversing a List and removing only certain elements based on logic, then you need to use Iterator's remove() method. This method removes current element from Iterator's perspective. If you use Collection's or List's remove() method during iteration then your code will throw ConcurrentModificationException. That's why it's advised to use Iterator remove() method to remove objects from Collection.
37)	What is difference between Synchronized Collection and Concurrent Collection?
Ans:- Java 5 has added several new Concurrent Collection classes e.g. ConcurrentHashMap, CopyOnWriteArrayList etc. Java Also provided way to get Synchronized copy of collection e.g. ArrayList, HashMap by using Collections.synchronizedMap() or Collections.synchronizedList() Utility functions. One Significant difference is that Concurrent Collections has better performance than synchronized Collection because they lock only a portion of Map to achieve concurrency and Synchronization.
38)	How does HashSet is implemented in Java, How does it uses Hashing ?

ans:- This is an interesting issue, because for hashing you need both key and value and there is no key for store it in a bucket, then how exactly HashSet store element internally. Well, HashSet is built on top of HashMap. If you look at source code of java.util.HashSet class, you will find that that it uses a HashMap with same values for all keys, as shown below :

private transient HashMap map;

// Dummy value to associate with an Object in the backing Map
private static final Object PRESENT = new Object();

When you call add() method of HashSet, it put entry in HashMap :

public boolean add(E e) {
  return map.put(e, PRESENT)==null;
}

Since keys are unique in a HashMap, it provides uniqueness guarantee of Set interface.
 
39)	When do you use ConcurrentHashMap in Java?
Ans:- ConcurrentHashMap is better suited for situation where you have multiple readers and one Writer or fewer writers since Map gets locked only during write operation .

40)	Mention some of the Best Practices of Collection API.
Ans:- Following are some of the best practices relating to Java Collection:
a)	Use ArrayList, HashMap etc. as opposed to Vector, Hashtable etc. , wherever possible to avoid synchronization overhead. Even better is to use just arrays where possible. If multiple threads concurrently access a collection and at least one of the threads either adds or deletes an entry into the collection , then the collection must be externally synchronized. This is achieved by 
Map myMap=Collections.synchronizedMap(myMap);
List myList=Collections.synchronizedList(myList);

b)	Set the initial capacity of a collection appropriately (e.g. ArrayList, HashMap  etc.) .  This is because Collection classes like ArrayList, HashMap etc. must grow periodically to accommodate new elements. But if you have a very large array and you know the size in advance then you can speed things up by setting the initial size appropriately.
e.g.  HashMaps/ Hashtables need to be created with sufficiently large capacity to minimize  rehashing ( which happens every time the table grows) . HashMap has two parameters initial capacity and load factor that affects its performance and space requirements.  Higher load factor values ( default load factor of 0.75 provides a good trade off bet’n  performance and space)  will reduce the space cost but will increase the lookup cost of myMap.get(….) and myMap.put(….) methods .  When the number of entries in the HashMap exceeds the current capacity * load factor then the capacity of  HashMap is roughly doubled by calling the rehash function. It is also very important not to set the initial capacity too high or load factor too low if iteration performance or reduction in space is important.

C) Program in terms of interface not implementation:  for example you might decide a LinkedList is the best choice  for some application, but then later decide ArrayList  might be  a better choice for performance reason.
Use:
	List list=new ArrayList(100);
Instead of
	ArrayList arr=new ArrayList();

d)	Return zero length collections or arrays as opposed to  returning null : returning null instead of zero length collection ( use Collections.EMPTY_SET, Collections.EMPTY_LIST,Collections.EMPTY_MAP) is more error-prone, since the programmer writing the calling method might forget to handle a return value of null.
e)	Immutable objects should be used as keys for the HashMap:  generally you use a java.lang.Integer or java.lang.String class as the key, which are immutable Java objects. If you define your own key class then it is a best practice to make the key class an immutable object ( i.e. do not provide any “setter” methods . 
f)	Encapsulate collections : in general collections are not immutable objects. So care should be taken not to unintentionally expose the collection fields to the caller.
Avoid
	The following code snippet exposes the Set “setCars” directly to the caller. This approach is riskier because the variable “cars” can be modified  unintentionally.
	public class CarYard
	{
		private Set<Car> cars=new HashSet<Car>();

		// exposes the cars to the caller
		public Set<Car> getCars()
		{
			return cars;
		}

		// exposes the cars to the caller
		public void setCars(Set<Car> cars)
		{
			this.cars=cars;
		}
}

Better approach
	This approach prevents the caller from directly using the underlying variable “cars”.

	public class CarYard
{
		private Set<Car> cars=new HashSet<Car>();
		public void addCar(Car car)
		{
			cars.add(car);
		}
		public void removeCar(Car car)
		{
			cars.remove(car);
		}

		public Set<Car> getCars()
		{
			// use factory method from the Collections
			return Collections.unmodifiableSet(cars);
		}

}

41)	What is hash collision? How does map implementations deal with it?
Ans:- When two or more different keys produce the same hash value, it’s called a Hash Collision. A map implementation deals with collisions by storing all the key/object pairs that have the same hash value in a same bucket ( i.e. in the form of linked list). Retrieving an object that resulted in a collision when it was stored is a two-step process. The key will be hashed to find the location where the key/object pair should be. The linked list then has to be searched to sort out the particular key you are searching on from all others that have the same hash value.
42)	 What is the difference between “put()” method of Map vs “add()” method of Set?
Ans:- 	“put” method of  Map
     * If the map previously contained a mapping for the key, the old
     * value is replaced.
		    public V put(K key, V value) { …….. }


		“add” method of Set
     * Adds the specified element to this set if it is not already present.
* If this set already contains the element, the call leaves the set
     * unchanged and returns false.
	    public boolean add(E e) {}

43)	How does “put()” method of map actually works?
Ans:- 
-- First of all, key object is checked for null. If key is null, value is stored in table[0] position. Because hash code for null is always 0.
-- Then on next step, a hash value is calculated using key’s hash code by calling its hashCode() method. This hash value is used to calculate index in array for storing Entry object. JDK designers well assumed that there might be some poorly written hashCode() functions that can return very high or low hash code value. To solve this issue, they introduced another hash() function, and passed the object’s hash code to this hash() function to bring hash value in range of array index size.
-- Now indexFor(hash, table.length) function is called to calculate exact index position for storing the Entry object.
-- Here comes the main part. Now, as we know that two unequal objects can have same hash code value, how two different objects will be stored in same array location [called bucket].
Answer is LinkedList. If you remember, Entry class had an attribute “next”. This attribute always points to next object in chain. This is exactly the behaviour of LinkedList.
So, in case of collision, Entry objects are stored in LinkedList form. When an Entry object needs to be stored in particular index, HashMap checks whether there is already an entry?? If there is no entry already present, Entry object is stored in this location.
If there is already an object sitting on calculated index, its next attribute is checked. If it is null, and current Entry object becomes next node in LinkedList. If next variable is not null, procedure is followed until next is evaluated as null.
44)	 What if we add the another value object inside map with same key (with matching hashcode and equals) as entered before?
Or
How do map implementations ensure the uniqueness of keys?
Ans:- Logically, it should replace the old value. How it is done? Well, after determining the index position of Entry object, while iterating over LinkedList on calculated index, HashMap calls equals method on key object for each Entry object. All these Entry objects in LinkedList will have similar hash code but equals() method will test for true equality. If newkey.equals(existingkey) will be true then both keys are treated as same key object. This will cause the replacing of value object inside Entry object only.
In this way, map implementations  ensure the uniqueness of keys.
45)	 Why ListIterator has add() method but Iterator doesn't or Why add() method is declared in ListIterator and not on Iterator.
Ans:- ListIterator has add() method because of its ability to traverse or iterate in both direction of collection. it maintains two pointers in terms of previous and next call and in position to add new element without affecting current iteration.

46)	 When does ConcurrentModificationException occur on iteration?
Ans:- When you remove or add object using Collection's or List's add or remove method e.g. add(Object element), remove(Object element) or remove(int index), instead of Iterator's remove() method than ConcurrentModificationException occur. As per Iterator's contract, if it detect any structural change in Collection e.g. adding or removing of element, once Iterator begins, it can throw ConcurrentModificationException. 

47)	Difference between ArrayList and LinkedList.
Ans:-  following are some of the imp points:
a)	Adding new elements is pretty fast for either type of list
b)	For the ArrayList, doing random lookup using "get" is fast, but for LinkedList, it's slow. It's slow because there's no efficient way to index into the middle of a linked list. Linkedlist lookup always start from 1st location.
c)	When removing  and inserting elements in between , using ArrayList is slow. This is because all remaining elements in the underlying array of Object instances must be shifted down for each removal or insertion operation. But LinkedList is fast, because deletion or insertion can be done simply by changing a couple of links. 
So an ArrayList works best for cases where you're doing random access on the list or adding at the end and a LinkedList works better if you're doing a lot of insertion or removal in the middle of the list. 

48)	 What is the difference between comparator and comparable in java?
Ans:-  Comparable
A comparable object is capable of comparing itself with another object. The class itself must implements the java.lang.Comparable interface in order to be able to compare its instances. 
Comparator
A comparator object is capable of comparing two different objects. The class is not comparing its instances, but some other class’s instances. This comparator class must implement the java.util.Comparator interface.
	Comparable and Comparator both are used for sorting the collection. Comparable provides only one sorting strategy whereas Comparator provides multiple sorting strategies.
For example, support ArrayList contains 100 Employee objects that have id, name, salary etc. If you want to sort the arraylist object based on id or name or salary, you should use Comparable interface. But if you want to sort the ArrayList object based on id then name then salary, you should use Comparator interface.
Implementing Comparable means "I can compare myself with another object." This is typically useful when there's a single natural default comparison.
Implementing Comparator means "I can compare two other objects." This is typically useful when there are multiple ways of comparing two instances of a type - e.g. you could compare people by age, name etc.

49)	What is CopyOnWriteArrayList?
Ans:-  A thread-safe variant of ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.
The "snapshot" style iterator method uses a reference to the state of the array at the point that the iterator was created. This array never changes during the lifetime of the iterator, so interference is impossible and the iterator is guaranteed not to throw ConcurrentModificationException. The iterator will not reflect additions, removals, or changes to the list since the iterator was created. Element-changing operations on iterators themselves (remove, set, and add) are not supported. These methods throwUnsupportedOperationException.
50)	 Explain ConcurrentHashMap in java.
Ans:-    ConcurrentHashMap is introduced as an alternative of Hashtable and provided all functions supported by Hashtable with additional feature called "concurrency level", which allows ConcurrentHashMap to partition Map. ConcurrentHashMap allows multiple readers to read concurrently without any blocking. This is achieved by partitioning Map into different parts based on concurrency level and locking only a portion of Map during updates. Default concurrency level is 16, and accordingly Map is divided into 16 part and each part is governed with different lock. This means, 16 thread can operate on Map simultaneously, until they are operating on different part of Map. This makes ConcurrentHashMap high performance despite keeping thread-safety intact.  Though, it comes with limitation. Since update operations like put(), remove(), putAll() or clear() is not synchronized, concurrent retrieval may not reflect most recent change on Map.

In case of putAll() or clear(), which operates on whole Map, concurrent read may reflect insertion and removal of only some entries. Another important point to remember is iteration over CHM, Iterator returned by keySet of ConcurrentHashMap are weakly consistent and they only reflect state of ConcurrentHashMap and certain point and may not reflect any recent change. Iterator of ConcurrentHashMap's keySet area also fail-safe and doesn’t throw ConcurrentModificationException..

Default concurrency level is 16 and can be changed, by providing a number which make sense and work for you while creating ConcurrentHashMap. Since concurrency level is used for internal sizing and indicate number of concurrent update without contention, so, if you just have few writers or thread to update Map keeping it low is much better. ConcurrentHashMap also uses ReentrantLock to internally lock its segments.

some more info about ConcurrentHashMap:
The definition of Segment is as below:

    /**
     * Inner Segment class
     * Plays a significant role
     */
    protected static final class Segment {
        protected int count;

        protected synchronized int getCount() {
            return this.count;
        }

        protected synchronized void synch() {}
    }
    
    /** Segment Array declaration **/
    public final Segment[] segments = new Segment[16];
    
    
As we all know that Map is a kind of data structure which stores data in key-value pair which is array of inner class Entry, see as below:

    static class Entry implements Map.Entry {
        
        protected final Object key;
        protected volatile Object value;
        protected final int hash;
        protected final Entry next;

        Entry(int hash, Object key, Object value, Entry next) {
            
            this.value = value;
            this.hash = hash;
            this.key = key;
            this.next = next;
        }
        
        // Code goes here like getter/setter 
    }
    
And ConcurrentHashMap class has an array defined as below of type Entry class:

    protected transient Entry[] table;
    
And this Entry array is getting initialized when we are creating an instance of ConcurrentHashMap even using default constructor as default constructor called this constructor internally as below:

    public ConcurrentHashMap(int initialCapacity, float loadFactor) {
        
        //Some code
        int cap = getCapacity();
        this.table = newTable(cap); // here this.table is Entry[] table
    }
    
    protected Entry[] newTable(int capacity) {
        this.threshold = ((int)(capacity * this.loadFactor / 16.0F) + 1);
        return new Entry[capacity];
    }
    
Here threshold is getting initialized for re-sizing purpose.
   
Inserting (Put) element in ConcurrentHashMap:-



Most important thing to understand the put method of ConcurrentHashMap, that how ConcurrentHashMap works when we are adding the element. As we know put method takes two arguments both of type Object as below:

    put(Object key, Object value)
    
So it wil 1st calculate the hash of key as below:

    int hashVal = hash(key);
    
    static int hash(Object x) {
        int h = x.hashCode();
        return (h << 7) - h + (h >>> 9) + (h >>> 17);
    }
        
After getting the hashVal we can decide the Segment as below:

    Segment seg = segments[(hash & 0x1F)];     // segments is an array defined above
    
Since its all about concurrency definetely we need synchronized block on the above Segment seg as below:

    synchronized (seg) {
     // code to add 
    
        int index = hash & table.length - 1; // hash we have calculated for key and table is Entry[] table
        Entry first = table[index];
        for (Entry e = first; e != null; e = e.next) {
            if ((e.hash == hash) && (eq(key, e.key))) { // if key already exist means updating the value
                Object oldValue = e.value;
                e.value = value;
                return oldValue;
            }
        }
        
        Entry newEntry = new Entry(hash, key, value, first); // new entry, i.e. this key not exist in map
        table[index] = newEntry;                             // Putting the Entry object at calculated Index  
    }

Size of ConcurrentHashMap:- 
    
Now when we are asking for size() of the ConcurrentHashMap the size comes as below:

    for (int i = 0; i < this.segments.length; i++) {
            c += this.segments[i].getCount();         //here c is an integer initialized with zero
    }    




Getting element from ConcurrentHashMap:-

when we are getting an element from ConcurrentHashMap we are simply passing key and hash of key is getting calculated. The defintion goes something like as below:

    public Object get(Object key){
        //some  code here
        
        int index = hash & table.length - 1;  //hash we have calculated for key and calculating index with help of hash
        Entry first = table[index];                          //table is Entry[] table
        for (Entry e = first; e != null; e = e.next) {
            if ((e.hash == hash) && (eq(key, e.key))) {
                Object value = e.value;
                if (value == null) {
                    break;
                }
                return value;
            }
        }
        //some  code here
    }
    
Note: No need to put any lock when getting the element from ConcurrentHashMap.





Removing element from ConcurrentHashMap:-

Now question is how remove works with ConcurrentHashMap, so let us understand it. Remove basically takes one argument 'Key' as an argument or takes two argument 'Key' and 'Value' as below:
    
    Object remove(Object key);
    boolean remove(Object key, Object value);
    
Now let us understand that how internally it works. The method remove(Object key) internally calls remove(Object key, Object value) where it passed 'null' as value. since we are going to remove an element from a Segment definitely we need a lock on the respected Segment.

    Object remove(Object key, Object value) {
    
        Segment seg = segments[(hash & 0x1F)];   //hash we have calculated for key
    
        synchronized (seg) {
            Entry[] tab = this.table;                //table is Entry[] table     
            int index = hash & tab.length - 1;       //calculating index with help of hash
            Entry first = tab[index];                //Getting the Entry Object
            
            Entry e = first;
            while(true) {
                if ((e.hash == hash) && (eq(key, e.key))) {
                    break;
                }
                e = e.next;
            }
            Object oldValue = e.value;
            Entry head = e.next;
            for (Entry p = first; p != e; p = p.next) {
                head = new Entry(p.hash, p.key, p.value, head);
            }
            table[index] = head;
            seg.count -= 1;
        }
        return oldValue;
    }
51)	 What is bucket ? 
Ans:- A bucket is used to store key value pairs . A bucket can have multiple key-value pairs . In hash map, bucket used simple linked list to store objects .
52)	 How will you retrieve Value object from map implementations if two Keys will have same hashcode?
ans:- first we will call get() method and then HashMap uses Key Object's hashcode to find out bucket location. After finding bucket location , we will call keys.equals() method to identify correct node in LinkedList and return associated value object for that key in Java HashMap .


53) draw the picture of entry table in case of map implementations.
Ans:-
 

53)	What happens On HashMap in Java if the size of the HashMap  exceeds a given threshold defined by load factor ?

ans:- If the size of the Map exceeds a given threshold defined by load-factor e.g. if load factor is .75 it will act to re-size the map once it filled 75%. Similar to other collection classes like ArrayList,  Java HashMap re-size itself by creating a new bucket array of size twice of previous size of HashMap , and then start putting every old element into that new bucket array. This process is called rehashing because it also applies hash function to find new bucket location. 

54) What do you mean by rehashing in case of map implementations?
Ans:- When the size of the Map exceeds a given threshold defined by load-factor e.g. if load factor is .75 it will act to re-size the map once it filled 75%. Map re-sizes itself by creating a new bucket array of size twice of previous size of map , and then start putting every old element into that new bucket array. This process is called as rehashing .

53) Why String, Integer and other wrapper classes are considered good keys?

ans:- String, Integer and other wrapper classes are natural candidates of HashMap key, and String is most frequently used key as well because String is immutable and final,and overrides equals and hashcode() method. Other wrapper class also shares similar property. Immutabiility is required, in order to prevent changes on fields used to calculate hashCode() because if key object return different hashCode during insertion and retrieval than it won't be possible to get object from HashMap. Immutability is best as it offers other advantages as well like thread-safety, If you can  keep your hashCode same by only making certain fields final, then you go for that as well. Since equals() and hashCode() method is used during reterival of value object from HashMap, it’s important that key object correctly override these methods and follow contact. If unequal object return different hashcode than chances of collision will be less which subsequently improve performance of HashMap.
54)	How does map resolves collision?
Ans:- When we call put method by passing key-value pair, “put” method invokes “hash()” method on Key hashCode() and  finds out the index to store the key-value pair. Now when u put another entry, there are two scenarios of hash collision:
a)	Hashcode of the given entry is same as existing entry/entries. – in this case == is called on key, if it matches, it overwrites the value. If == doesn’t match, then “equals()” is invoked ,if it returns true then  overwrites the value. If not linked list is formed.
b)	 Hashcode of the given entry is different from the existing keys in the map, but index returned from the “hash()” is same as that of existing entries. – in this case also linked list is formed.
a and b prove that hash collision can happen in two cases ie. When hashcode is same as existing entries or when hashcode  is different but index is same as that of existing entries.
When we call get method by passing Key, again it uses “hash()” function which uses the hashCode() of given key to find the index in the array and then uses ==. If == returns true, it returns the value , if it returns false,then equals() method is invoked , if it returns true value is returned otherwise next node inside the linkedlist is traversed to find the correct Entry and return it’s value.

55)	How do you traverse through a collection using its Iterator?
Ans:- To use an iterator to traverse through the contents of a collection, follow these steps:
•	Obtain an iterator to the start of the collection by calling the collection implementation’s  iterator() method.
•	Set up a loop that makes a call to hasNext(). Have the loop iterate as long as hasNext() returns true. 
•	Within the loop, obtain each element by calling next().

60) What are the advantages of ArrayList over arrays ?
Ans:- Some of the advantages ArrayList has over arrays are: 
•	It can grow dynamically
•	It provides more powerful insertion and search mechanisms than arrays.
•	It can have iterators associated which can traverse bidirectionally.
•	They are serialized in nature.
61)Why insertion and deletion in ArrayList is slow compared to LinkedList ? 
•	Ans:- ArrayList internally uses and array to store the elements, when that array gets filled by inserting elements a new array of roughly 1.5 times the size of the original array is created and all the data of old array is copied to new array.
•	During deletion, all elements present in the array after the deleted elements have to be moved one step back to fill the space created by deletion. In linked list data is stored in nodes that have reference to the previous node and the next node so adding element is simple as creating the node an updating the next pointer on the last node and the previous pointer on the new node. Deletion in linked list is fast because it involves only updating the next pointer in the node before the deleted node and updating the previous pointer in the node after the deleted node. 
62) Why are Iterators returned by ArrayList called Fail Fast ?
Ans:- Because, if list is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.
63) How do you decide when to use ArrayList and When to use LinkedList?
Ans:- If you need to support random access, without inserting or removing elements from any place other than the end, then ArrayList offers the optimal collection. If, however, you need to frequently add and remove elements from the middle of the list and only access the list elements sequentially, then LinkedList offers the better implementation.
64) Difference between ArrayList and Vector.
Ans:- 
ArrayList	Vector 
ArrayList is NOT synchronized by default.	Vector List is synchronized by default.
ArrayList can use only Iterator to access the elements.	Vector list can use Iterator and Enumeration Interface to access the elements.
65) explain Collection API hierarchy.

 
66) What is the difference between Enumerator, Iterator and ListIterator?
Ans:- 
Property	Enumeration	Iterator	ListIterator
Number of method	2	3	9
Method names	hasMoreElements(), nextElement()	hasNext(), next(), remove().	add(), hasNext(), next(), hasPrevious(), previous(), nextIndex(), previousIndex(), set(),remove(). 
Access Direction	Forward-only	Forward only	Bi-directional
Summary	It provides a read only traversal of the collection. Legacy classes such as Vector and HashTable’s  methods returns this	Iterator provides a method to remove an element from the iterator. Java Collection Framework classes methods return this.	It provides a bi-directional access on the collection and hence has methods to support it, like previous() and next(). It also allows the modification of elements using set() and add() operation.
67) what is the difference between Hashtable and ConcurrentHashMap?
Ans:- both can be used in multithreaded environment but once the size of hashtable becomes considerable large, performance degrade because for iteration it has to be locked for longer duration.

Since ConcurrentHashMap introduced concept of segmentation , how large it becomes only certain part of it get locked to provide thread safety so many other readers can still access map without waiting for iteration to complete.

In Summary ConcurrentHashMap only locked certain portion of Map while Hashtable lock full map while doing iteration.
68) What is the difference between Synchronized Collection classes and Concurrent Collection Classes ?
Ans:- The synchronized collections classes, Hashtable and Vector, and the synchronized wrapper classes, Collections.synchronizedMap and Collections.synchronizedList, provide a basic conditionally thread-safe implementation of Map and List.
However, several factors make them unsuitable for use in highly concurrent applications -- their single collection-wide lock is a hurdle to scalability and it often becomes necessary to lock a collection for a considerable time during iteration to prevent ConcurrentModificationExceptions.

The ConcurrentHashMap and CopyOnWriteArrayList implementations provide much higher concurrency while preserving thread safety, with some minor compromises in their promises to callers. ConcurrentHashMap and CopyOnWriteArrayList are not necessarily useful everywhere you might use HashMap or ArrayList, but are designed to optimize specific common situations. Many concurrent applications will benefit from their use.
69) what is the drawback of  synchronized collections classes, Hashtable and Vector, and the synchronized wrapper classes, Collections.synchronizedMap and Collections.synchronizedList etc. ?
Ans:- The simple approach to synchronization taken by both Hashtable and synchronizedMap -- synchronizing each method on the Hashtable or the synchronized Map wrapper object -- has two principal deficiencies. It is an obstacle to scalability, because only one thread can access the hash table at a time. At the same time, it is insufficient to provide true thread safety, in that many common compound operations still require additional synchronization. While simple operations such as get() and put() can complete safely without additional synchronization, there are several common sequences of operations, such as iteration or put-if-absent, which still require external synchronization to avoid data races.
70) what is heap pollution?
Ans:- heap pollution is a situation that arises when a variable of a parameterized type refers to an object that is not of that parameterized type.This situation is normally detected during compilation and indicated with an unchecked warning. Later, during runtime heap pollution will often cause a ClassCastException. Consider following example:
List ln = new ArrayList<Number>(); 
		ln.add(10);
		List<String> ls =ln;  // unchecked warning 
		String s = ls.get(0); // ClassCastException 
		System.out.println(s);
After the assignment of the reference variable  ln  to the reference variable ls , the  List<String> variable will point to a  List<Number> object. Such a situation is called  heap pollution and is usually indicated by an unchecked warning.  A polluted heap is likely to lead to an unexpected  ClassCastException at runtime.  In the example above, it will lead to a  ClassCastException , when a object is retrieved from the  List<String> and assigned to a  String variable, because the object is a  Number , not  a String .

71) even after creating Collections.synchronizedList(new ArrayList()), why do we need to use “synchronized” block?
Ans:- a) If you only access your list using elementary operations (add(), remove(), etc) and invocations of these operations don't depend on each other (i.e. atomicity is not an issue), you can use only synchronizedList() without explicit synchronized blocks
b)	If you want to be able to invoke elementary operations without synchronized blocks, but also have compound operations (including iteration) that should be atomic, you need both synchronizedList() and synchronized blocks for compound operations.

72) discuss the problem of thread-safety with synchronized collection classes as well as synchronized wrapper classes.
Ans:- both are thread safe. As their individual methods are synchronized.
I.e.
Vector myvect=new Vector();
	or
List list = Collections.synchronizedList(new ArrayList(...));

In java.util.Collections' JavaDoc you can read that "It is imperative
that the user manually synchronize on the returned list or vector when iterating
over it:"

synchronized(list) {
Iterator i = list.iterator(); // Must be in synchronized block
while (i.hasNext())
foo(i.next());
}

Now if synchronizedList gives me  a thread-safe List implementation , why do I need to use explicit synchronization?

Vector and synchronizedList() both end up synchronizing each individual method call - but they do not provide any protection against other threads changing the thread in between individual method calls. So any time you rely on some sort of consistent state in between two method calls, there is a possibility of failure. 

For example: 
1.	for (Foo f : fooVector) {  
2.	  doSomethingWith(f);  
3.	}  


1.	Iterator<Foo> it = fooVector.iterator();  
2.	while (it.hasNext()) {  
3.	  Foo f = (Foo) it.next();  
4.	  doSomethingWith(f);  
5.	}  

OK, that's normal enough. But if fooVector is also accessible to other threads which can modify it, problems can occur. What happens if something changes in between the calls to it.hasNext() and it.next()? 
1.	Iterator<Foo> it = fooVector.iterator();  
2.	while (it.hasNext()) {  
3.	  // other thread calls fooVector.remove(0)  
4.	  Foo f = (Foo) it.next(); // now this line may throw NoSuchElementException  
5.	  doSomethingWith(f);  
6.	}  
 

To avoid this problem, it's necessary to synchronize as described in the List.iterator() API: 
1.	synchronized (fooVector) {  
2.	  Iterator<Foo> it = fooVector.iterator();  
3.	  while (it.hasNext()) {  
4.	    Foo f = (Foo) it.next();  
5.	    doSomethingWith(f);  
6.	  }  
7.	}  

But this problem is not limited to use of Iterators. Here's another example: 
1.	if (!fooVector.isEmpty()) {  
2.	  Foo f = fooVector.remove(0);  
3.	  doSomethingWith(f);  
4.	}  

Here, again - what if, in between the isEmpty() and the remove(0), another thread removes the only element in fooVector? You get a NoSuchElementException. 

Or a more common example, getting the last element of a List: 
1.	Foo lastFoo = fooList.get(fooList.size() - 1);  

The call to fooList.size() must execute before fooList.get(). What happens if a single element is removed from the list, in between these two operations? NoSuchElementException. Or if a single element is added, anywhere in the list (except the very end)- oops, you just got the next-to-last element, rather than the last one. 

To summarize, Both synchronized collection classes and synchronized wrapper classes seem to give people a false sense of confidence that their code is thread-safe, when it really isn't. Additional synchronization is almost always needed




76) what is the requirement of putting any key inside TreeMap or element inside TreeSet?
Ans:- Whether u want to put any key inside TreeMap or element inside TreeSet u need to fulfil one of the following requirements:
a)	Key must implement “Comparable” interface so that u will define “compareTo(Object)” method and provide the strategy to compare a particular field.
b)	If key is not implementing “Comparable”, then u need to create an implementation of “Comparator” by defining “compare(Object,Object)” to provide the strategy to compare a particular field. Now pass this Comparator implementation to TreeMap or TreeSet constructor. When u put a key inside TreeMap or add an element inside TreeSet, outcome of compare() method will be considered.

77) what is the difference between C++ class template and Java Generics?
Ans:- 
1.	In C++ templates, parameters can be any type or integral but in Java, parameters can only be reference types (not primitive types).
1	std::map<int, int> mapping;

1	Map<Integer, Integer> mapping;

2.	For C++ templates, Separate copies of the class or function are likely to be generated for each type parameter when compiled (this is also known as “template code bloat”). However for Java generics, only one version of the class or function is compiled and it works for all type parameters.
3.	For C++ templates, Implementation source code of the template class or function must be included in order to use it (declaration sufficient). For Java templates, Signature of the class or function from a compiled class file is sufficient to use it.
4.	C++ templates can be specialized - a separate implementation could be provided for a particular template parameter. In Java, generics cannot be specialized.

78) Explain HashMap changes in Java8.
Ans:- 
Though HashMap implementation provides constant time performance O(1) for get() and put() method but that is in the ideal case when the Hash function distributes the objects evenly among the buckets.
But the performance may worsen in the case hashCode() used is not proper and there are lots of hash collisions. As we know now that in case of hash collision entry objects are stored as a node in a linked-list and equals() method is used to compare keys. That comparison to find the correct key with in a linked-list is a linear operation so in a worst case scenario the complexity becomes O(n).
To address this issue in Java 8 hash elements use balanced trees instead of linked lists after a certain threshold is reached. Which means HashMap starts with storing Entry objects in linked list but after the number of items in a hash becomes larger than a certain threshold, the hash will change from using a linked list to a balanced tree, this will improve the worst case performance from O(n) to O(log n).


81) How will you make Collections readOnly ?


We can make the Collection readOnly by using the following lines code:

General : Collections.unmodifiableCollection(Collection c)

Collections.unmodifiableMap(Map m)
Collections.unmodifiableList(List l)
Collections.unmodifiableSet(Set s)

82)  What is UnsupportedOperationException?

This exception is thrown to indicate that the requested operation is not supported.
Example of UnsupportedOperationException:
In other words, if you call add() or remove() method on the readOnly collection . We know readOnly collection can not be modified . Hence , UnsupportedOperationException will be thrown.
83) Suppose there is an Employee class. We add Employee class objects to the ArrayList. Mention the steps need to be taken , if I want to sort the objects in ArrayList using the employeeId attribute present  in Employee class. 

a. Implement the Comparable interface for the Employee class and now to compare the objects by employeeId we will override the emp1.compareTo(emp2)
b. We will now call Collections class sort method and pass the list as argument , that is ,
     Collections.sort(empList)  

 
